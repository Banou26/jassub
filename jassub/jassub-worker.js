var Module = typeof Module !== 'undefined' ? Module : {}; if (!Module.expectedDataFileDownloads) { Module.expectedDataFileDownloads = 0 }Module.expectedDataFileDownloads++; (function () { const loadPackage = function (metadata) { let PACKAGE_PATH = ''; if (typeof window === 'object') { PACKAGE_PATH = window.encodeURIComponent(window.location.pathname.toString().substring(0, window.location.pathname.toString().lastIndexOf('/')) + '/') } else if (typeof process === 'undefined' && typeof location !== 'undefined') { PACKAGE_PATH = encodeURIComponent(location.pathname.toString().substring(0, location.pathname.toString().lastIndexOf('/')) + '/') } const PACKAGE_NAME = 'dist/js/jassub-worker.data'; const REMOTE_PACKAGE_BASE = 'jassub-worker.data'; if (typeof Module.locateFilePackage === 'function' && !Module.locateFile) { Module.locateFile = Module.locateFilePackage; err('warning: you defined Module.locateFilePackage, that has been renamed to Module.locateFile (using your locateFilePackage for now)') } const REMOTE_PACKAGE_NAME = Module.locateFile ? Module.locateFile(REMOTE_PACKAGE_BASE, '') : REMOTE_PACKAGE_BASE; const REMOTE_PACKAGE_SIZE = metadata.remote_package_size; const PACKAGE_UUID = metadata.package_uuid; function fetchRemotePackage (packageName, packageSize, callback, errback) { const xhr = new XMLHttpRequest(); xhr.open('GET', packageName, true); xhr.responseType = 'arraybuffer'; xhr.onprogress = function (event) { const url = packageName; let size = packageSize; if (event.total)size = event.total; if (event.loaded) { if (!xhr.addedTotal) { xhr.addedTotal = true; if (!Module.dataFileDownloads)Module.dataFileDownloads = {}; Module.dataFileDownloads[url] = { loaded: event.loaded, total: size } } else { Module.dataFileDownloads[url].loaded = event.loaded } let total = 0; let loaded = 0; let num = 0; for (const download in Module.dataFileDownloads) { const data = Module.dataFileDownloads[download]; total += data.total; loaded += data.loaded; num++ }total = Math.ceil(total * Module.expectedDataFileDownloads / num); if (Module.setStatus)Module.setStatus('Downloading data... (' + loaded + '/' + total + ')') } else if (!Module.dataFileDownloads) { if (Module.setStatus)Module.setStatus('Downloading data...') } }; xhr.onerror = function (event) { throw new Error('NetworkError for: ' + packageName) }; xhr.onload = function (event) { if (xhr.status == 200 || xhr.status == 304 || xhr.status == 206 || xhr.status == 0 && xhr.response) { const packageData = xhr.response; callback(packageData) } else { throw new Error(xhr.statusText + ' : ' + xhr.responseURL) } }; xhr.send(null) } function handleError (error) { console.error('package error:', error) } let fetchedCallback = null; let fetched = Module.getPreloadedPackage ? Module.getPreloadedPackage(REMOTE_PACKAGE_NAME, REMOTE_PACKAGE_SIZE) : null; if (!fetched)fetchRemotePackage(REMOTE_PACKAGE_NAME, REMOTE_PACKAGE_SIZE, function (data) { if (fetchedCallback) { fetchedCallback(data); fetchedCallback = null } else { fetched = data } }, handleError); function runWithFS () { function assert (check, msg) { if (!check) throw msg + (new Error()).stack }Module.FS_createPath('/', 'assets', true, true); function DataRequest (start, end, audio) { this.start = start; this.end = end; this.audio = audio }DataRequest.prototype = { requests: {}, open: function (mode, name) { this.name = name; this.requests[name] = this; Module.addRunDependency('fp ' + this.name) }, send: function () {}, onload: function () { const byteArray = this.byteArray.subarray(this.start, this.end); this.finish(byteArray) }, finish: function (byteArray) { const that = this; Module.FS_createDataFile(this.name, null, byteArray, true, true, true); Module.removeRunDependency('fp ' + that.name); this.requests[this.name] = null } }; const files = metadata.files; for (let i = 0; i < files.length; ++i) { new DataRequest(files[i].start, files[i].end, files[i].audio || 0).open('GET', files[i].filename) } function processPackageData (arrayBuffer) { assert(arrayBuffer, 'Loading data file failed.'); assert(arrayBuffer instanceof ArrayBuffer, 'bad input to processPackageData'); const byteArray = new Uint8Array(arrayBuffer); DataRequest.prototype.byteArray = byteArray; const files = metadata.files; for (let i = 0; i < files.length; ++i) { DataRequest.prototype.requests[files[i].filename].onload() }Module.removeRunDependency('datafile_dist/js/jassub-worker.data') }Module.addRunDependency('datafile_dist/js/jassub-worker.data'); if (!Module.preloadResults)Module.preloadResults = {}; Module.preloadResults[PACKAGE_NAME] = { fromCache: false }; if (fetched) { processPackageData(fetched); fetched = null } else { fetchedCallback = processPackageData } } if (Module.calledRun) { runWithFS() } else { if (!Module.preRun)Module.preRun = []; Module.preRun.push(runWithFS) } }; loadPackage({ files: [{ filename: '/assets/fonts.conf', start: 0, end: 803 }], remote_package_size: 803, package_uuid: 'e8bf09e2-cbf4-47b4-b8c3-7606b5a60bf6' }) })(); if (!String.prototype.startsWith) { String.prototype.startsWith = function (search, pos) { if (pos === undefined) { pos = 0 } return this.substring(pos, search.length) === search } } if (!String.prototype.endsWith) { String.prototype.endsWith = function (search, len) { if (len === undefined || len > this.length) { len = this.length } return this.substring(len - search.length, len) === search } } if (!String.prototype.includes) { String.prototype.includes = function (search, pos) { return this.indexOf(search, pos) !== -1 } } if (!ArrayBuffer.isView) { const typedArrays = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array]; ArrayBuffer.isView = function (obj) { return obj && obj.constructor && typedArrays.indexOf(obj.constructor) !== -1 } } if (!Int8Array.prototype.slice) { Object.defineProperty(Int8Array.prototype, 'slice', { value: function (begin, end) { return new Int8Array(this.subarray(begin, end)) } }) } if (!Uint8Array.prototype.slice) { Object.defineProperty(Uint8Array.prototype, 'slice', { value: function (begin, end) { return new Uint8Array(this.subarray(begin, end)) } }) } if (!Int16Array.from) { Int16Array.from = function (source) { const arr = new Int16Array(source.length); arr.set(source, 0); return arr } } if (!Int32Array.from) { Int32Array.from = function (source) { const arr = new Int32Array(source.length); arr.set(source, 0); return arr } }Date.now = Date.now || function () { return (new Date()).getTime() }; let moduleOverrides = {}; let key; for (key in Module) { if (Module.hasOwnProperty(key)) { moduleOverrides[key] = Module[key] } } const arguments_ = []; const thisProgram = './this.program'; const quit_ = function (status, toThrow) { throw toThrow }; const ENVIRONMENT_IS_WEB = false; const ENVIRONMENT_IS_WORKER = true; let scriptDirectory = ''; function locateFile (path) { return scriptDirectory + path } let read_, readAsync, readBinary, setWindowTitle; if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) { if (ENVIRONMENT_IS_WORKER) { scriptDirectory = self.location.href } else if (typeof document !== 'undefined' && document.currentScript) { scriptDirectory = document.currentScript.src } if (scriptDirectory.indexOf('blob:') !== 0) { scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, '').lastIndexOf('/') + 1) } else { scriptDirectory = '' } { read_ = function (url) { const xhr = new XMLHttpRequest(); xhr.open('GET', url, false); xhr.send(null); return xhr.responseText }; if (ENVIRONMENT_IS_WORKER) { readBinary = function (url) { const xhr = new XMLHttpRequest(); xhr.open('GET', url, false); xhr.responseType = 'arraybuffer'; xhr.send(null); return new Uint8Array(xhr.response) } }readAsync = function (url, onload, onerror) { const xhr = new XMLHttpRequest(); xhr.open('GET', url, true); xhr.responseType = 'arraybuffer'; xhr.onload = function () { if (xhr.status == 200 || xhr.status == 0 && xhr.response) { onload(xhr.response); return }onerror() }; xhr.onerror = onerror; xhr.send(null) } }setWindowTitle = function (title) { document.title = title } } else {} const out = Module.print || console.log.bind(console); var err = Module.printErr || console.warn.bind(console); for (key in moduleOverrides) { if (moduleOverrides.hasOwnProperty(key)) { Module[key] = moduleOverrides[key] } }moduleOverrides = null; let tempRet0 = 0; const setTempRet0 = function (value) { tempRet0 = value }; const getTempRet0 = function () { return tempRet0 }; let wasmBinary; const noExitRuntime = true; if (typeof WebAssembly !== 'object') { abort('no native wasm support detected') } let wasmMemory; let ABORT = false; let EXITSTATUS; function assert (condition, text) { if (!condition) { abort('Assertion failed: ' + text) } } const UTF8Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined; function UTF8ArrayToString (heap, idx, maxBytesToRead) { const endIdx = idx + maxBytesToRead; let endPtr = idx; while (heap[endPtr] && !(endPtr >= endIdx))++endPtr; if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) { return UTF8Decoder.decode(heap.subarray(idx, endPtr)) } else { var str = ''; while (idx < endPtr) { let u0 = heap[idx++]; if (!(u0 & 128)) { str += String.fromCharCode(u0); continue } const u1 = heap[idx++] & 63; if ((u0 & 224) == 192) { str += String.fromCharCode((u0 & 31) << 6 | u1); continue } const u2 = heap[idx++] & 63; if ((u0 & 240) == 224) { u0 = (u0 & 15) << 12 | u1 << 6 | u2 } else { u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heap[idx++] & 63 } if (u0 < 65536) { str += String.fromCharCode(u0) } else { const ch = u0 - 65536; str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023) } } } return str } function UTF8ToString (ptr, maxBytesToRead) { return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '' } function stringToUTF8Array (str, heap, outIdx, maxBytesToWrite) { if (!(maxBytesToWrite > 0)) return 0; const startIdx = outIdx; const endIdx = outIdx + maxBytesToWrite - 1; for (let i = 0; i < str.length; ++i) { let u = str.charCodeAt(i); if (u >= 55296 && u <= 57343) { const u1 = str.charCodeAt(++i); u = 65536 + ((u & 1023) << 10) | u1 & 1023 } if (u <= 127) { if (outIdx >= endIdx) break; heap[outIdx++] = u } else if (u <= 2047) { if (outIdx + 1 >= endIdx) break; heap[outIdx++] = 192 | u >> 6; heap[outIdx++] = 128 | u & 63 } else if (u <= 65535) { if (outIdx + 2 >= endIdx) break; heap[outIdx++] = 224 | u >> 12; heap[outIdx++] = 128 | u >> 6 & 63; heap[outIdx++] = 128 | u & 63 } else { if (outIdx + 3 >= endIdx) break; heap[outIdx++] = 240 | u >> 18; heap[outIdx++] = 128 | u >> 12 & 63; heap[outIdx++] = 128 | u >> 6 & 63; heap[outIdx++] = 128 | u & 63 } }heap[outIdx] = 0; return outIdx - startIdx } function stringToUTF8 (str, outPtr, maxBytesToWrite) { return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite) } function lengthBytesUTF8 (str) { let len = 0; for (let i = 0; i < str.length; ++i) { let u = str.charCodeAt(i); if (u >= 55296 && u <= 57343)u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023; if (u <= 127)++len; else if (u <= 2047)len += 2; else if (u <= 65535)len += 3; else len += 4 } return len } function allocateUTF8OnStack (str) { const size = lengthBytesUTF8(str) + 1; const ret = stackAlloc(size); stringToUTF8Array(str, HEAP8, ret, size); return ret } function writeAsciiToMemory (str, buffer, dontAddNull) { for (let i = 0; i < str.length; ++i) { HEAP8[buffer++ >> 0] = str.charCodeAt(i) } if (!dontAddNull)HEAP8[buffer >> 0] = 0 } function alignUp (x, multiple) { if (x % multiple > 0) { x += multiple - x % multiple } return x } let buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64; function updateGlobalBufferAndViews (buf) { buffer = buf; Module.HEAP8 = HEAP8 = new Int8Array(buf); Module.HEAP16 = HEAP16 = new Int16Array(buf); Module.HEAP32 = HEAP32 = new Int32Array(buf); Module.HEAPU8 = HEAPU8 = new Uint8Array(buf); Module.HEAPU16 = HEAPU16 = new Uint16Array(buf); Module.HEAPU32 = HEAPU32 = new Uint32Array(buf); Module.HEAPF32 = HEAPF32 = new Float32Array(buf); Module.HEAPF64 = HEAPF64 = new Float64Array(buf) } let wasmTable; const __ATPRERUN__ = []; const __ATINIT__ = []; const __ATMAIN__ = []; const __ATPOSTRUN__ = []; let runtimeInitialized = false; let runtimeExited = false; const runtimeKeepaliveCounter = 0; function keepRuntimeAlive () { return noExitRuntime || runtimeKeepaliveCounter > 0 } function preRun () { if (Module.preRun) { if (typeof Module.preRun === 'function')Module.preRun = [Module.preRun]; while (Module.preRun.length) { addOnPreRun(Module.preRun.shift()) } }callRuntimeCallbacks(__ATPRERUN__) } function initRuntime () { runtimeInitialized = true; if (!Module.noFSInit && !FS.init.initialized)FS.init(); FS.ignorePermissions = false; TTY.init(); callRuntimeCallbacks(__ATINIT__) } function preMain () { callRuntimeCallbacks(__ATMAIN__) } function exitRuntime () { runtimeExited = true } function postRun () { callRuntimeCallbacks(__ATPOSTRUN__) } function addOnPreRun (cb) { __ATPRERUN__.unshift(cb) } function addOnInit (cb) { __ATINIT__.unshift(cb) } let runDependencies = 0; let runDependencyWatcher = null; let dependenciesFulfilled = null; function getUniqueRunDependency (id) { return id } function addRunDependency (id) { runDependencies++ } function removeRunDependency (id) { runDependencies--; if (runDependencies == 0) { if (runDependencyWatcher !== null) { clearInterval(runDependencyWatcher); runDependencyWatcher = null } if (dependenciesFulfilled) { const callback = dependenciesFulfilled; dependenciesFulfilled = null; callback() } } }Module.preloadedImages = {}; Module.preloadedAudios = {}; function abort (what) { what = 'Aborted(' + what + ')'; err(what); ABORT = true; EXITSTATUS = 1; what += '. Build with -s ASSERTIONS=1 for more info.'; const e = new WebAssembly.RuntimeError(what); throw e } const dataURIPrefix = 'data:application/octet-stream;base64,'; function isDataURI (filename) { return filename.startsWith(dataURIPrefix) } let wasmBinaryFile; wasmBinaryFile = 'jassub-worker.wasm'; if (!isDataURI(wasmBinaryFile)) { wasmBinaryFile = locateFile(wasmBinaryFile) } function getBinary (file) { try { if (file == wasmBinaryFile && wasmBinary) { return new Uint8Array(wasmBinary) } if (readBinary) { return readBinary(file) } else { throw 'both async and sync fetching of the wasm failed' } } catch (err) { abort(err) } } function getBinaryPromise () { if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) { if (typeof fetch === 'function') { return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function (response) { if (!response.ok) { throw "failed to load wasm binary file at '" + wasmBinaryFile + "'" } return response.arrayBuffer() }).catch(function () { return getBinary(wasmBinaryFile) }) } } return Promise.resolve().then(function () { return getBinary(wasmBinaryFile) }) } function createWasm () { const info = { a: asmLibraryArg }; function receiveInstance (instance, module) { const exports = instance.exports; Module.asm = exports; wasmMemory = Module.asm.N; updateGlobalBufferAndViews(wasmMemory.buffer); wasmTable = Module.asm.Gc; addOnInit(Module.asm.O); removeRunDependency('wasm-instantiate') }addRunDependency('wasm-instantiate'); function receiveInstantiationResult (result) { receiveInstance(result.instance) } function instantiateArrayBuffer (receiver) { return getBinaryPromise().then(function (binary) { return WebAssembly.instantiate(binary, info) }).then(function (instance) { return instance }).then(receiver, function (reason) { err('failed to asynchronously prepare wasm: ' + reason); abort(reason) }) } function instantiateAsync () { if (!wasmBinary && typeof WebAssembly.instantiateStreaming === 'function' && !isDataURI(wasmBinaryFile) && typeof fetch === 'function') { return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function (response) { const result = WebAssembly.instantiateStreaming(response, info); return result.then(receiveInstantiationResult, function (reason) { err('wasm streaming compile failed: ' + reason); err('falling back to ArrayBuffer instantiation'); return instantiateArrayBuffer(receiveInstantiationResult) }) }) } else { return instantiateArrayBuffer(receiveInstantiationResult) } } if (Module.instantiateWasm) { try { const exports = Module.instantiateWasm(info, receiveInstance); return exports } catch (e) { err('Module.instantiateWasm callback failed with error: ' + e); return false } }instantiateAsync(); return {} } let tempDouble; let tempI64; function callRuntimeCallbacks (callbacks) { while (callbacks.length > 0) { const callback = callbacks.shift(); if (typeof callback === 'function') { callback(Module); continue } const func = callback.func; if (typeof func === 'number') { if (callback.arg === undefined) { getWasmTableEntry(func)() } else { getWasmTableEntry(func)(callback.arg) } } else { func(callback.arg === undefined ? null : callback.arg) } } } const wasmTableMirror = []; function getWasmTableEntry (funcPtr) { let func = wasmTableMirror[funcPtr]; if (!func) { if (funcPtr >= wasmTableMirror.length)wasmTableMirror.length = funcPtr + 1; wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr) } return func } function handleException (e) { if (e instanceof ExitStatus || e == 'unwind') { return EXITSTATUS }quit_(1, e) } function ___assert_fail (condition, filename, line, func) { abort('Assertion failed: ' + UTF8ToString(condition) + ', at: ' + [filename ? UTF8ToString(filename) : 'unknown filename', line, func ? UTF8ToString(func) : 'unknown function']) } let _emscripten_get_now; _emscripten_get_now = function () { return performance.now() }; const _emscripten_get_now_is_monotonic = true; function setErrNo (value) { HEAP32[___errno_location() >> 2] = value; return value } function _clock_gettime (clk_id, tp) { let now; if (clk_id === 0) { now = Date.now() } else if ((clk_id === 1 || clk_id === 4) && _emscripten_get_now_is_monotonic) { now = _emscripten_get_now() } else { setErrNo(28); return -1 }HEAP32[tp >> 2] = now / 1e3 | 0; HEAP32[tp + 4 >> 2] = now % 1e3 * 1e3 * 1e3 | 0; return 0 } function ___clock_gettime (a0, a1) { return _clock_gettime(a0, a1) } var PATH = { splitPath: function (filename) { const splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/; return splitPathRe.exec(filename).slice(1) }, normalizeArray: function (parts, allowAboveRoot) { let up = 0; for (let i = parts.length - 1; i >= 0; i--) { const last = parts[i]; if (last === '.') { parts.splice(i, 1) } else if (last === '..') { parts.splice(i, 1); up++ } else if (up) { parts.splice(i, 1); up-- } } if (allowAboveRoot) { for (;up; up--) { parts.unshift('..') } } return parts }, normalize: function (path) { const isAbsolute = path.charAt(0) === '/'; const trailingSlash = path.substr(-1) === '/'; path = PATH.normalizeArray(path.split('/').filter(function (p) { return !!p }), !isAbsolute).join('/'); if (!path && !isAbsolute) { path = '.' } if (path && trailingSlash) { path += '/' } return (isAbsolute ? '/' : '') + path }, dirname: function (path) { const result = PATH.splitPath(path); const root = result[0]; let dir = result[1]; if (!root && !dir) { return '.' } if (dir) { dir = dir.substr(0, dir.length - 1) } return root + dir }, basename: function (path) { if (path === '/') return '/'; path = PATH.normalize(path); path = path.replace(/\/$/, ''); const lastSlash = path.lastIndexOf('/'); if (lastSlash === -1) return path; return path.substr(lastSlash + 1) }, extname: function (path) { return PATH.splitPath(path)[3] }, join: function () { const paths = Array.prototype.slice.call(arguments, 0); return PATH.normalize(paths.join('/')) }, join2: function (l, r) { return PATH.normalize(l + '/' + r) } }; function getRandomDevice () { if (typeof crypto === 'object' && typeof crypto.getRandomValues === 'function') { const randomBuffer = new Uint8Array(1); return function () { crypto.getRandomValues(randomBuffer); return randomBuffer[0] } } else return function () { abort('randomDevice') } } var PATH_FS = { resolve: function () { let resolvedPath = ''; let resolvedAbsolute = false; for (let i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) { const path = i >= 0 ? arguments[i] : FS.cwd(); if (typeof path !== 'string') { throw new TypeError('Arguments to path.resolve must be strings') } else if (!path) { return '' }resolvedPath = path + '/' + resolvedPath; resolvedAbsolute = path.charAt(0) === '/' }resolvedPath = PATH.normalizeArray(resolvedPath.split('/').filter(function (p) { return !!p }), !resolvedAbsolute).join('/'); return (resolvedAbsolute ? '/' : '') + resolvedPath || '.' }, relative: function (from, to) { from = PATH_FS.resolve(from).substr(1); to = PATH_FS.resolve(to).substr(1); function trim (arr) { let start = 0; for (;start < arr.length; start++) { if (arr[start] !== '') break } let end = arr.length - 1; for (;end >= 0; end--) { if (arr[end] !== '') break } if (start > end) return []; return arr.slice(start, end - start + 1) } const fromParts = trim(from.split('/')); const toParts = trim(to.split('/')); const length = Math.min(fromParts.length, toParts.length); let samePartsLength = length; for (var i = 0; i < length; i++) { if (fromParts[i] !== toParts[i]) { samePartsLength = i; break } } let outputParts = []; for (var i = samePartsLength; i < fromParts.length; i++) { outputParts.push('..') }outputParts = outputParts.concat(toParts.slice(samePartsLength)); return outputParts.join('/') } }; var TTY = { ttys: [], init: function () {}, shutdown: function () {}, register: function (dev, ops) { TTY.ttys[dev] = { input: [], output: [], ops }; FS.registerDevice(dev, TTY.stream_ops) }, stream_ops: { open: function (stream) { const tty = TTY.ttys[stream.node.rdev]; if (!tty) { throw new FS.ErrnoError(43) }stream.tty = tty; stream.seekable = false }, close: function (stream) { stream.tty.ops.flush(stream.tty) }, flush: function (stream) { stream.tty.ops.flush(stream.tty) }, read: function (stream, buffer, offset, length, pos) { if (!stream.tty || !stream.tty.ops.get_char) { throw new FS.ErrnoError(60) } let bytesRead = 0; for (let i = 0; i < length; i++) { var result; try { result = stream.tty.ops.get_char(stream.tty) } catch (e) { throw new FS.ErrnoError(29) } if (result === undefined && bytesRead === 0) { throw new FS.ErrnoError(6) } if (result === null || result === undefined) break; bytesRead++; buffer[offset + i] = result } if (bytesRead) { stream.node.timestamp = Date.now() } return bytesRead }, write: function (stream, buffer, offset, length, pos) { if (!stream.tty || !stream.tty.ops.put_char) { throw new FS.ErrnoError(60) } try { for (var i = 0; i < length; i++) { stream.tty.ops.put_char(stream.tty, buffer[offset + i]) } } catch (e) { throw new FS.ErrnoError(29) } if (length) { stream.node.timestamp = Date.now() } return i } }, default_tty_ops: { get_char: function (tty) { if (!tty.input.length) { let result = null; if (typeof window !== 'undefined' && typeof window.prompt === 'function') { result = window.prompt('Input: '); if (result !== null) { result += '\n' } } else if (typeof readline === 'function') { result = readline(); if (result !== null) { result += '\n' } } if (!result) { return null }tty.input = intArrayFromString(result, true) } return tty.input.shift() }, put_char: function (tty, val) { if (val === null || val === 10) { out(UTF8ArrayToString(tty.output, 0)); tty.output = [] } else { if (val != 0)tty.output.push(val) } }, flush: function (tty) { if (tty.output && tty.output.length > 0) { out(UTF8ArrayToString(tty.output, 0)); tty.output = [] } } }, default_tty1_ops: { put_char: function (tty, val) { if (val === null || val === 10) { err(UTF8ArrayToString(tty.output, 0)); tty.output = [] } else { if (val != 0)tty.output.push(val) } }, flush: function (tty) { if (tty.output && tty.output.length > 0) { err(UTF8ArrayToString(tty.output, 0)); tty.output = [] } } } }; function zeroMemory (address, size) { HEAPU8.fill(0, address, address + size) } function alignMemory (size, alignment) { return Math.ceil(size / alignment) * alignment } function mmapAlloc (size) { size = alignMemory(size, 65536); const ptr = _memalign(65536, size); if (!ptr) return 0; zeroMemory(ptr, size); return ptr } var MEMFS = { ops_table: null, mount: function (mount) { return MEMFS.createNode(null, '/', 16384 | 511, 0) }, createNode: function (parent, name, mode, dev) { if (FS.isBlkdev(mode) || FS.isFIFO(mode)) { throw new FS.ErrnoError(63) } if (!MEMFS.ops_table) { MEMFS.ops_table = { dir: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, lookup: MEMFS.node_ops.lookup, mknod: MEMFS.node_ops.mknod, rename: MEMFS.node_ops.rename, unlink: MEMFS.node_ops.unlink, rmdir: MEMFS.node_ops.rmdir, readdir: MEMFS.node_ops.readdir, symlink: MEMFS.node_ops.symlink }, stream: { llseek: MEMFS.stream_ops.llseek } }, file: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: { llseek: MEMFS.stream_ops.llseek, read: MEMFS.stream_ops.read, write: MEMFS.stream_ops.write, allocate: MEMFS.stream_ops.allocate, mmap: MEMFS.stream_ops.mmap, msync: MEMFS.stream_ops.msync } }, link: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, readlink: MEMFS.node_ops.readlink }, stream: {} }, chrdev: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: FS.chrdev_stream_ops } } } const node = FS.createNode(parent, name, mode, dev); if (FS.isDir(node.mode)) { node.node_ops = MEMFS.ops_table.dir.node; node.stream_ops = MEMFS.ops_table.dir.stream; node.contents = {} } else if (FS.isFile(node.mode)) { node.node_ops = MEMFS.ops_table.file.node; node.stream_ops = MEMFS.ops_table.file.stream; node.usedBytes = 0; node.contents = null } else if (FS.isLink(node.mode)) { node.node_ops = MEMFS.ops_table.link.node; node.stream_ops = MEMFS.ops_table.link.stream } else if (FS.isChrdev(node.mode)) { node.node_ops = MEMFS.ops_table.chrdev.node; node.stream_ops = MEMFS.ops_table.chrdev.stream }node.timestamp = Date.now(); if (parent) { parent.contents[name] = node; parent.timestamp = node.timestamp } return node }, getFileDataAsTypedArray: function (node) { if (!node.contents) return new Uint8Array(0); if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes); return new Uint8Array(node.contents) }, expandFileStorage: function (node, newCapacity) { const prevCapacity = node.contents ? node.contents.length : 0; if (prevCapacity >= newCapacity) return; const CAPACITY_DOUBLING_MAX = 1024 * 1024; newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0); if (prevCapacity != 0)newCapacity = Math.max(newCapacity, 256); const oldContents = node.contents; node.contents = new Uint8Array(newCapacity); if (node.usedBytes > 0)node.contents.set(oldContents.subarray(0, node.usedBytes), 0) }, resizeFileStorage: function (node, newSize) { if (node.usedBytes == newSize) return; if (newSize == 0) { node.contents = null; node.usedBytes = 0 } else { const oldContents = node.contents; node.contents = new Uint8Array(newSize); if (oldContents) { node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes))) }node.usedBytes = newSize } }, node_ops: { getattr: function (node) { const attr = {}; attr.dev = FS.isChrdev(node.mode) ? node.id : 1; attr.ino = node.id; attr.mode = node.mode; attr.nlink = 1; attr.uid = 0; attr.gid = 0; attr.rdev = node.rdev; if (FS.isDir(node.mode)) { attr.size = 4096 } else if (FS.isFile(node.mode)) { attr.size = node.usedBytes } else if (FS.isLink(node.mode)) { attr.size = node.link.length } else { attr.size = 0 }attr.atime = new Date(node.timestamp); attr.mtime = new Date(node.timestamp); attr.ctime = new Date(node.timestamp); attr.blksize = 4096; attr.blocks = Math.ceil(attr.size / attr.blksize); return attr }, setattr: function (node, attr) { if (attr.mode !== undefined) { node.mode = attr.mode } if (attr.timestamp !== undefined) { node.timestamp = attr.timestamp } if (attr.size !== undefined) { MEMFS.resizeFileStorage(node, attr.size) } }, lookup: function (parent, name) { throw FS.genericErrors[44] }, mknod: function (parent, name, mode, dev) { return MEMFS.createNode(parent, name, mode, dev) }, rename: function (old_node, new_dir, new_name) { if (FS.isDir(old_node.mode)) { let new_node; try { new_node = FS.lookupNode(new_dir, new_name) } catch (e) {} if (new_node) { for (const i in new_node.contents) { throw new FS.ErrnoError(55) } } } delete old_node.parent.contents[old_node.name]; old_node.parent.timestamp = Date.now(); old_node.name = new_name; new_dir.contents[new_name] = old_node; new_dir.timestamp = old_node.parent.timestamp; old_node.parent = new_dir }, unlink: function (parent, name) { delete parent.contents[name]; parent.timestamp = Date.now() }, rmdir: function (parent, name) { const node = FS.lookupNode(parent, name); for (const i in node.contents) { throw new FS.ErrnoError(55) } delete parent.contents[name]; parent.timestamp = Date.now() }, readdir: function (node) { const entries = ['.', '..']; for (const key in node.contents) { if (!node.contents.hasOwnProperty(key)) { continue }entries.push(key) } return entries }, symlink: function (parent, newname, oldpath) { const node = MEMFS.createNode(parent, newname, 511 | 40960, 0); node.link = oldpath; return node }, readlink: function (node) { if (!FS.isLink(node.mode)) { throw new FS.ErrnoError(28) } return node.link } }, stream_ops: { read: function (stream, buffer, offset, length, position) { const contents = stream.node.contents; if (position >= stream.node.usedBytes) return 0; const size = Math.min(stream.node.usedBytes - position, length); if (size > 8 && contents.subarray) { buffer.set(contents.subarray(position, position + size), offset) } else { for (let i = 0; i < size; i++)buffer[offset + i] = contents[position + i] } return size }, write: function (stream, buffer, offset, length, position, canOwn) { if (buffer.buffer === HEAP8.buffer) { canOwn = false } if (!length) return 0; const node = stream.node; node.timestamp = Date.now(); if (buffer.subarray && (!node.contents || node.contents.subarray)) { if (canOwn) { node.contents = buffer.subarray(offset, offset + length); node.usedBytes = length; return length } else if (node.usedBytes === 0 && position === 0) { node.contents = buffer.slice(offset, offset + length); node.usedBytes = length; return length } else if (position + length <= node.usedBytes) { node.contents.set(buffer.subarray(offset, offset + length), position); return length } }MEMFS.expandFileStorage(node, position + length); if (node.contents.subarray && buffer.subarray) { node.contents.set(buffer.subarray(offset, offset + length), position) } else { for (let i = 0; i < length; i++) { node.contents[position + i] = buffer[offset + i] } }node.usedBytes = Math.max(node.usedBytes, position + length); return length }, llseek: function (stream, offset, whence) { let position = offset; if (whence === 1) { position += stream.position } else if (whence === 2) { if (FS.isFile(stream.node.mode)) { position += stream.node.usedBytes } } if (position < 0) { throw new FS.ErrnoError(28) } return position }, allocate: function (stream, offset, length) { MEMFS.expandFileStorage(stream.node, offset + length); stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length) }, mmap: function (stream, address, length, position, prot, flags) { if (address !== 0) { throw new FS.ErrnoError(28) } if (!FS.isFile(stream.node.mode)) { throw new FS.ErrnoError(43) } let ptr; let allocated; let contents = stream.node.contents; if (!(flags & 2) && contents.buffer === buffer) { allocated = false; ptr = contents.byteOffset } else { if (position > 0 || position + length < contents.length) { if (contents.subarray) { contents = contents.subarray(position, position + length) } else { contents = Array.prototype.slice.call(contents, position, position + length) } }allocated = true; ptr = mmapAlloc(length); if (!ptr) { throw new FS.ErrnoError(48) }HEAP8.set(contents, ptr) } return { ptr, allocated } }, msync: function (stream, buffer, offset, length, mmapFlags) { if (!FS.isFile(stream.node.mode)) { throw new FS.ErrnoError(43) } if (mmapFlags & 2) { return 0 } const bytesWritten = MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false); return 0 } } }; function asyncLoad (url, onload, onerror, noRunDep) { const dep = !noRunDep ? getUniqueRunDependency('al ' + url) : ''; readAsync(url, function (arrayBuffer) { assert(arrayBuffer, 'Loading data file "' + url + '" failed (no arrayBuffer).'); onload(new Uint8Array(arrayBuffer)); if (dep)removeRunDependency(dep) }, function (event) { if (onerror) { onerror() } else { throw 'Loading data file "' + url + '" failed.' } }); if (dep)addRunDependency(dep) } var FS = { root: null, mounts: [], devices: {}, streams: [], nextInode: 1, nameTable: null, currentPath: '/', initialized: false, ignorePermissions: true, ErrnoError: null, genericErrors: {}, filesystems: null, syncFSRequests: 0, lookupPath: function (path, opts) { path = PATH_FS.resolve(FS.cwd(), path); opts = opts || {}; if (!path) return { path: '', node: null }; const defaults = { follow_mount: true, recurse_count: 0 }; for (const key in defaults) { if (opts[key] === undefined) { opts[key] = defaults[key] } } if (opts.recurse_count > 8) { throw new FS.ErrnoError(32) } const parts = PATH.normalizeArray(path.split('/').filter(function (p) { return !!p }), false); let current = FS.root; let current_path = '/'; for (let i = 0; i < parts.length; i++) { const islast = i === parts.length - 1; if (islast && opts.parent) { break }current = FS.lookupNode(current, parts[i]); current_path = PATH.join2(current_path, parts[i]); if (FS.isMountpoint(current)) { if (!islast || islast && opts.follow_mount) { current = current.mounted.root } } if (!islast || opts.follow) { let count = 0; while (FS.isLink(current.mode)) { const link = FS.readlink(current_path); current_path = PATH_FS.resolve(PATH.dirname(current_path), link); const lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count }); current = lookup.node; if (count++ > 40) { throw new FS.ErrnoError(32) } } } } return { path: current_path, node: current } }, getPath: function (node) { let path; while (true) { if (FS.isRoot(node)) { const mount = node.mount.mountpoint; if (!path) return mount; return mount[mount.length - 1] !== '/' ? mount + '/' + path : mount + path }path = path ? node.name + '/' + path : node.name; node = node.parent } }, hashName: function (parentid, name) { let hash = 0; for (let i = 0; i < name.length; i++) { hash = (hash << 5) - hash + name.charCodeAt(i) | 0 } return (parentid + hash >>> 0) % FS.nameTable.length }, hashAddNode: function (node) { const hash = FS.hashName(node.parent.id, node.name); node.name_next = FS.nameTable[hash]; FS.nameTable[hash] = node }, hashRemoveNode: function (node) { const hash = FS.hashName(node.parent.id, node.name); if (FS.nameTable[hash] === node) { FS.nameTable[hash] = node.name_next } else { let current = FS.nameTable[hash]; while (current) { if (current.name_next === node) { current.name_next = node.name_next; break }current = current.name_next } } }, lookupNode: function (parent, name) { const errCode = FS.mayLookup(parent); if (errCode) { throw new FS.ErrnoError(errCode, parent) } const hash = FS.hashName(parent.id, name); for (let node = FS.nameTable[hash]; node; node = node.name_next) { const nodeName = node.name; if (node.parent.id === parent.id && nodeName === name) { return node } } return FS.lookup(parent, name) }, createNode: function (parent, name, mode, rdev) { const node = new FS.FSNode(parent, name, mode, rdev); FS.hashAddNode(node); return node }, destroyNode: function (node) { FS.hashRemoveNode(node) }, isRoot: function (node) { return node === node.parent }, isMountpoint: function (node) { return !!node.mounted }, isFile: function (mode) { return (mode & 61440) === 32768 }, isDir: function (mode) { return (mode & 61440) === 16384 }, isLink: function (mode) { return (mode & 61440) === 40960 }, isChrdev: function (mode) { return (mode & 61440) === 8192 }, isBlkdev: function (mode) { return (mode & 61440) === 24576 }, isFIFO: function (mode) { return (mode & 61440) === 4096 }, isSocket: function (mode) { return (mode & 49152) === 49152 }, flagModes: { r: 0, 'r+': 2, w: 577, 'w+': 578, a: 1089, 'a+': 1090 }, modeStringToFlags: function (str) { const flags = FS.flagModes[str]; if (typeof flags === 'undefined') { throw new Error('Unknown file open mode: ' + str) } return flags }, flagsToPermissionString: function (flag) { let perms = ['r', 'w', 'rw'][flag & 3]; if (flag & 512) { perms += 'w' } return perms }, nodePermissions: function (node, perms) { if (FS.ignorePermissions) { return 0 } if (perms.includes('r') && !(node.mode & 292)) { return 2 } else if (perms.includes('w') && !(node.mode & 146)) { return 2 } else if (perms.includes('x') && !(node.mode & 73)) { return 2 } return 0 }, mayLookup: function (dir) { const errCode = FS.nodePermissions(dir, 'x'); if (errCode) return errCode; if (!dir.node_ops.lookup) return 2; return 0 }, mayCreate: function (dir, name) { try { const node = FS.lookupNode(dir, name); return 20 } catch (e) {} return FS.nodePermissions(dir, 'wx') }, mayDelete: function (dir, name, isdir) { let node; try { node = FS.lookupNode(dir, name) } catch (e) { return e.errno } const errCode = FS.nodePermissions(dir, 'wx'); if (errCode) { return errCode } if (isdir) { if (!FS.isDir(node.mode)) { return 54 } if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) { return 10 } } else { if (FS.isDir(node.mode)) { return 31 } } return 0 }, mayOpen: function (node, flags) { if (!node) { return 44 } if (FS.isLink(node.mode)) { return 32 } else if (FS.isDir(node.mode)) { if (FS.flagsToPermissionString(flags) !== 'r' || flags & 512) { return 31 } } return FS.nodePermissions(node, FS.flagsToPermissionString(flags)) }, MAX_OPEN_FDS: 4096, nextfd: function (fd_start, fd_end) { fd_start = fd_start || 0; fd_end = fd_end || FS.MAX_OPEN_FDS; for (let fd = fd_start; fd <= fd_end; fd++) { if (!FS.streams[fd]) { return fd } } throw new FS.ErrnoError(33) }, getStream: function (fd) { return FS.streams[fd] }, createStream: function (stream, fd_start, fd_end) { if (!FS.FSStream) { FS.FSStream = function () {}; FS.FSStream.prototype = { object: { get: function () { return this.node }, set: function (val) { this.node = val } }, isRead: { get: function () { return (this.flags & 2097155) !== 1 } }, isWrite: { get: function () { return (this.flags & 2097155) !== 0 } }, isAppend: { get: function () { return this.flags & 1024 } } } } const newStream = new FS.FSStream(); for (const p in stream) { newStream[p] = stream[p] }stream = newStream; const fd = FS.nextfd(fd_start, fd_end); stream.fd = fd; FS.streams[fd] = stream; return stream }, closeStream: function (fd) { FS.streams[fd] = null }, chrdev_stream_ops: { open: function (stream) { const device = FS.getDevice(stream.node.rdev); stream.stream_ops = device.stream_ops; if (stream.stream_ops.open) { stream.stream_ops.open(stream) } }, llseek: function () { throw new FS.ErrnoError(70) } }, major: function (dev) { return dev >> 8 }, minor: function (dev) { return dev & 255 }, makedev: function (ma, mi) { return ma << 8 | mi }, registerDevice: function (dev, ops) { FS.devices[dev] = { stream_ops: ops } }, getDevice: function (dev) { return FS.devices[dev] }, getMounts: function (mount) { const mounts = []; const check = [mount]; while (check.length) { const m = check.pop(); mounts.push(m); check.push.apply(check, m.mounts) } return mounts }, syncfs: function (populate, callback) { if (typeof populate === 'function') { callback = populate; populate = false }FS.syncFSRequests++; if (FS.syncFSRequests > 1) { err('warning: ' + FS.syncFSRequests + ' FS.syncfs operations in flight at once, probably just doing extra work') } const mounts = FS.getMounts(FS.root.mount); let completed = 0; function doCallback (errCode) { FS.syncFSRequests--; return callback(errCode) } function done (errCode) { if (errCode) { if (!done.errored) { done.errored = true; return doCallback(errCode) } return } if (++completed >= mounts.length) { doCallback(null) } }mounts.forEach(function (mount) { if (!mount.type.syncfs) { return done(null) }mount.type.syncfs(mount, populate, done) }) }, mount: function (type, opts, mountpoint) { const root = mountpoint === '/'; const pseudo = !mountpoint; let node; if (root && FS.root) { throw new FS.ErrnoError(10) } else if (!root && !pseudo) { const lookup = FS.lookupPath(mountpoint, { follow_mount: false }); mountpoint = lookup.path; node = lookup.node; if (FS.isMountpoint(node)) { throw new FS.ErrnoError(10) } if (!FS.isDir(node.mode)) { throw new FS.ErrnoError(54) } } const mount = { type, opts, mountpoint, mounts: [] }; const mountRoot = type.mount(mount); mountRoot.mount = mount; mount.root = mountRoot; if (root) { FS.root = mountRoot } else if (node) { node.mounted = mount; if (node.mount) { node.mount.mounts.push(mount) } } return mountRoot }, unmount: function (mountpoint) { const lookup = FS.lookupPath(mountpoint, { follow_mount: false }); if (!FS.isMountpoint(lookup.node)) { throw new FS.ErrnoError(28) } const node = lookup.node; const mount = node.mounted; const mounts = FS.getMounts(mount); Object.keys(FS.nameTable).forEach(function (hash) { let current = FS.nameTable[hash]; while (current) { const next = current.name_next; if (mounts.includes(current.mount)) { FS.destroyNode(current) }current = next } }); node.mounted = null; const idx = node.mount.mounts.indexOf(mount); node.mount.mounts.splice(idx, 1) }, lookup: function (parent, name) { return parent.node_ops.lookup(parent, name) }, mknod: function (path, mode, dev) { const lookup = FS.lookupPath(path, { parent: true }); const parent = lookup.node; const name = PATH.basename(path); if (!name || name === '.' || name === '..') { throw new FS.ErrnoError(28) } const errCode = FS.mayCreate(parent, name); if (errCode) { throw new FS.ErrnoError(errCode) } if (!parent.node_ops.mknod) { throw new FS.ErrnoError(63) } return parent.node_ops.mknod(parent, name, mode, dev) }, create: function (path, mode) { mode = mode !== undefined ? mode : 438; mode &= 4095; mode |= 32768; return FS.mknod(path, mode, 0) }, mkdir: function (path, mode) { mode = mode !== undefined ? mode : 511; mode &= 511 | 512; mode |= 16384; return FS.mknod(path, mode, 0) }, mkdirTree: function (path, mode) { const dirs = path.split('/'); let d = ''; for (let i = 0; i < dirs.length; ++i) { if (!dirs[i]) continue; d += '/' + dirs[i]; try { FS.mkdir(d, mode) } catch (e) { if (e.errno != 20) throw e } } }, mkdev: function (path, mode, dev) { if (typeof dev === 'undefined') { dev = mode; mode = 438 }mode |= 8192; return FS.mknod(path, mode, dev) }, symlink: function (oldpath, newpath) { if (!PATH_FS.resolve(oldpath)) { throw new FS.ErrnoError(44) } const lookup = FS.lookupPath(newpath, { parent: true }); const parent = lookup.node; if (!parent) { throw new FS.ErrnoError(44) } const newname = PATH.basename(newpath); const errCode = FS.mayCreate(parent, newname); if (errCode) { throw new FS.ErrnoError(errCode) } if (!parent.node_ops.symlink) { throw new FS.ErrnoError(63) } return parent.node_ops.symlink(parent, newname, oldpath) }, rename: function (old_path, new_path) { const old_dirname = PATH.dirname(old_path); const new_dirname = PATH.dirname(new_path); const old_name = PATH.basename(old_path); const new_name = PATH.basename(new_path); let lookup, old_dir, new_dir; lookup = FS.lookupPath(old_path, { parent: true }); old_dir = lookup.node; lookup = FS.lookupPath(new_path, { parent: true }); new_dir = lookup.node; if (!old_dir || !new_dir) throw new FS.ErrnoError(44); if (old_dir.mount !== new_dir.mount) { throw new FS.ErrnoError(75) } const old_node = FS.lookupNode(old_dir, old_name); let relative = PATH_FS.relative(old_path, new_dirname); if (relative.charAt(0) !== '.') { throw new FS.ErrnoError(28) }relative = PATH_FS.relative(new_path, old_dirname); if (relative.charAt(0) !== '.') { throw new FS.ErrnoError(55) } let new_node; try { new_node = FS.lookupNode(new_dir, new_name) } catch (e) {} if (old_node === new_node) { return } const isdir = FS.isDir(old_node.mode); let errCode = FS.mayDelete(old_dir, old_name, isdir); if (errCode) { throw new FS.ErrnoError(errCode) }errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name); if (errCode) { throw new FS.ErrnoError(errCode) } if (!old_dir.node_ops.rename) { throw new FS.ErrnoError(63) } if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) { throw new FS.ErrnoError(10) } if (new_dir !== old_dir) { errCode = FS.nodePermissions(old_dir, 'w'); if (errCode) { throw new FS.ErrnoError(errCode) } }FS.hashRemoveNode(old_node); try { old_dir.node_ops.rename(old_node, new_dir, new_name) } catch (e) { throw e } finally { FS.hashAddNode(old_node) } }, rmdir: function (path) { const lookup = FS.lookupPath(path, { parent: true }); const parent = lookup.node; const name = PATH.basename(path); const node = FS.lookupNode(parent, name); const errCode = FS.mayDelete(parent, name, true); if (errCode) { throw new FS.ErrnoError(errCode) } if (!parent.node_ops.rmdir) { throw new FS.ErrnoError(63) } if (FS.isMountpoint(node)) { throw new FS.ErrnoError(10) }parent.node_ops.rmdir(parent, name); FS.destroyNode(node) }, readdir: function (path) { const lookup = FS.lookupPath(path, { follow: true }); const node = lookup.node; if (!node.node_ops.readdir) { throw new FS.ErrnoError(54) } return node.node_ops.readdir(node) }, unlink: function (path) { const lookup = FS.lookupPath(path, { parent: true }); const parent = lookup.node; const name = PATH.basename(path); const node = FS.lookupNode(parent, name); const errCode = FS.mayDelete(parent, name, false); if (errCode) { throw new FS.ErrnoError(errCode) } if (!parent.node_ops.unlink) { throw new FS.ErrnoError(63) } if (FS.isMountpoint(node)) { throw new FS.ErrnoError(10) }parent.node_ops.unlink(parent, name); FS.destroyNode(node) }, readlink: function (path) { const lookup = FS.lookupPath(path); const link = lookup.node; if (!link) { throw new FS.ErrnoError(44) } if (!link.node_ops.readlink) { throw new FS.ErrnoError(28) } return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link)) }, stat: function (path, dontFollow) { const lookup = FS.lookupPath(path, { follow: !dontFollow }); const node = lookup.node; if (!node) { throw new FS.ErrnoError(44) } if (!node.node_ops.getattr) { throw new FS.ErrnoError(63) } return node.node_ops.getattr(node) }, lstat: function (path) { return FS.stat(path, true) }, chmod: function (path, mode, dontFollow) { let node; if (typeof path === 'string') { const lookup = FS.lookupPath(path, { follow: !dontFollow }); node = lookup.node } else { node = path } if (!node.node_ops.setattr) { throw new FS.ErrnoError(63) }node.node_ops.setattr(node, { mode: mode & 4095 | node.mode & ~4095, timestamp: Date.now() }) }, lchmod: function (path, mode) { FS.chmod(path, mode, true) }, fchmod: function (fd, mode) { const stream = FS.getStream(fd); if (!stream) { throw new FS.ErrnoError(8) }FS.chmod(stream.node, mode) }, chown: function (path, uid, gid, dontFollow) { let node; if (typeof path === 'string') { const lookup = FS.lookupPath(path, { follow: !dontFollow }); node = lookup.node } else { node = path } if (!node.node_ops.setattr) { throw new FS.ErrnoError(63) }node.node_ops.setattr(node, { timestamp: Date.now() }) }, lchown: function (path, uid, gid) { FS.chown(path, uid, gid, true) }, fchown: function (fd, uid, gid) { const stream = FS.getStream(fd); if (!stream) { throw new FS.ErrnoError(8) }FS.chown(stream.node, uid, gid) }, truncate: function (path, len) { if (len < 0) { throw new FS.ErrnoError(28) } let node; if (typeof path === 'string') { const lookup = FS.lookupPath(path, { follow: true }); node = lookup.node } else { node = path } if (!node.node_ops.setattr) { throw new FS.ErrnoError(63) } if (FS.isDir(node.mode)) { throw new FS.ErrnoError(31) } if (!FS.isFile(node.mode)) { throw new FS.ErrnoError(28) } const errCode = FS.nodePermissions(node, 'w'); if (errCode) { throw new FS.ErrnoError(errCode) }node.node_ops.setattr(node, { size: len, timestamp: Date.now() }) }, ftruncate: function (fd, len) { const stream = FS.getStream(fd); if (!stream) { throw new FS.ErrnoError(8) } if ((stream.flags & 2097155) === 0) { throw new FS.ErrnoError(28) }FS.truncate(stream.node, len) }, utime: function (path, atime, mtime) { const lookup = FS.lookupPath(path, { follow: true }); const node = lookup.node; node.node_ops.setattr(node, { timestamp: Math.max(atime, mtime) }) }, open: function (path, flags, mode, fd_start, fd_end) { if (path === '') { throw new FS.ErrnoError(44) }flags = typeof flags === 'string' ? FS.modeStringToFlags(flags) : flags; mode = typeof mode === 'undefined' ? 438 : mode; if (flags & 64) { mode = mode & 4095 | 32768 } else { mode = 0 } let node; if (typeof path === 'object') { node = path } else { path = PATH.normalize(path); try { const lookup = FS.lookupPath(path, { follow: !(flags & 131072) }); node = lookup.node } catch (e) {} } let created = false; if (flags & 64) { if (node) { if (flags & 128) { throw new FS.ErrnoError(20) } } else { node = FS.mknod(path, mode, 0); created = true } } if (!node) { throw new FS.ErrnoError(44) } if (FS.isChrdev(node.mode)) { flags &= ~512 } if (flags & 65536 && !FS.isDir(node.mode)) { throw new FS.ErrnoError(54) } if (!created) { const errCode = FS.mayOpen(node, flags); if (errCode) { throw new FS.ErrnoError(errCode) } } if (flags & 512) { FS.truncate(node, 0) }flags &= ~(128 | 512 | 131072); const stream = FS.createStream({ node, path: FS.getPath(node), id: node.id, flags, mode: node.mode, seekable: true, position: 0, stream_ops: node.stream_ops, node_ops: node.node_ops, ungotten: [], error: false }, fd_start, fd_end); if (stream.stream_ops.open) { stream.stream_ops.open(stream) } if (Module.logReadFiles && !(flags & 1)) { if (!FS.readFiles)FS.readFiles = {}; if (!(path in FS.readFiles)) { FS.readFiles[path] = 1 } } return stream }, close: function (stream) { if (FS.isClosed(stream)) { throw new FS.ErrnoError(8) } if (stream.getdents)stream.getdents = null; try { if (stream.stream_ops.close) { stream.stream_ops.close(stream) } } catch (e) { throw e } finally { FS.closeStream(stream.fd) }stream.fd = null }, isClosed: function (stream) { return stream.fd === null }, llseek: function (stream, offset, whence) { if (FS.isClosed(stream)) { throw new FS.ErrnoError(8) } if (!stream.seekable || !stream.stream_ops.llseek) { throw new FS.ErrnoError(70) } if (whence != 0 && whence != 1 && whence != 2) { throw new FS.ErrnoError(28) }stream.position = stream.stream_ops.llseek(stream, offset, whence); stream.ungotten = []; return stream.position }, read: function (stream, buffer, offset, length, position) { if (length < 0 || position < 0) { throw new FS.ErrnoError(28) } if (FS.isClosed(stream)) { throw new FS.ErrnoError(8) } if ((stream.flags & 2097155) === 1) { throw new FS.ErrnoError(8) } if (FS.isDir(stream.node.mode)) { throw new FS.ErrnoError(31) } if (!stream.stream_ops.read) { throw new FS.ErrnoError(28) } const seeking = typeof position !== 'undefined'; if (!seeking) { position = stream.position } else if (!stream.seekable) { throw new FS.ErrnoError(70) } const bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position); if (!seeking)stream.position += bytesRead; return bytesRead }, write: function (stream, buffer, offset, length, position, canOwn) { if (length < 0 || position < 0) { throw new FS.ErrnoError(28) } if (FS.isClosed(stream)) { throw new FS.ErrnoError(8) } if ((stream.flags & 2097155) === 0) { throw new FS.ErrnoError(8) } if (FS.isDir(stream.node.mode)) { throw new FS.ErrnoError(31) } if (!stream.stream_ops.write) { throw new FS.ErrnoError(28) } if (stream.seekable && stream.flags & 1024) { FS.llseek(stream, 0, 2) } const seeking = typeof position !== 'undefined'; if (!seeking) { position = stream.position } else if (!stream.seekable) { throw new FS.ErrnoError(70) } const bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn); if (!seeking)stream.position += bytesWritten; return bytesWritten }, allocate: function (stream, offset, length) { if (FS.isClosed(stream)) { throw new FS.ErrnoError(8) } if (offset < 0 || length <= 0) { throw new FS.ErrnoError(28) } if ((stream.flags & 2097155) === 0) { throw new FS.ErrnoError(8) } if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) { throw new FS.ErrnoError(43) } if (!stream.stream_ops.allocate) { throw new FS.ErrnoError(138) }stream.stream_ops.allocate(stream, offset, length) }, mmap: function (stream, address, length, position, prot, flags) { if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) { throw new FS.ErrnoError(2) } if ((stream.flags & 2097155) === 1) { throw new FS.ErrnoError(2) } if (!stream.stream_ops.mmap) { throw new FS.ErrnoError(43) } return stream.stream_ops.mmap(stream, address, length, position, prot, flags) }, msync: function (stream, buffer, offset, length, mmapFlags) { if (!stream || !stream.stream_ops.msync) { return 0 } return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags) }, munmap: function (stream) { return 0 }, ioctl: function (stream, cmd, arg) { if (!stream.stream_ops.ioctl) { throw new FS.ErrnoError(59) } return stream.stream_ops.ioctl(stream, cmd, arg) }, readFile: function (path, opts) { opts = opts || {}; opts.flags = opts.flags || 0; opts.encoding = opts.encoding || 'binary'; if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') { throw new Error('Invalid encoding type "' + opts.encoding + '"') } let ret; const stream = FS.open(path, opts.flags); const stat = FS.stat(path); const length = stat.size; const buf = new Uint8Array(length); FS.read(stream, buf, 0, length, 0); if (opts.encoding === 'utf8') { ret = UTF8ArrayToString(buf, 0) } else if (opts.encoding === 'binary') { ret = buf }FS.close(stream); return ret }, writeFile: function (path, data, opts) { opts = opts || {}; opts.flags = opts.flags || 577; const stream = FS.open(path, opts.flags, opts.mode); if (typeof data === 'string') { const buf = new Uint8Array(lengthBytesUTF8(data) + 1); const actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length); FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn) } else if (ArrayBuffer.isView(data)) { FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn) } else { throw new Error('Unsupported data type') }FS.close(stream) }, cwd: function () { return FS.currentPath }, chdir: function (path) { const lookup = FS.lookupPath(path, { follow: true }); if (lookup.node === null) { throw new FS.ErrnoError(44) } if (!FS.isDir(lookup.node.mode)) { throw new FS.ErrnoError(54) } const errCode = FS.nodePermissions(lookup.node, 'x'); if (errCode) { throw new FS.ErrnoError(errCode) }FS.currentPath = lookup.path }, createDefaultDirectories: function () { FS.mkdir('/tmp'); FS.mkdir('/home'); FS.mkdir('/home/web_user') }, createDefaultDevices: function () { FS.mkdir('/dev'); FS.registerDevice(FS.makedev(1, 3), { read: function () { return 0 }, write: function (stream, buffer, offset, length, pos) { return length } }); FS.mkdev('/dev/null', FS.makedev(1, 3)); TTY.register(FS.makedev(5, 0), TTY.default_tty_ops); TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops); FS.mkdev('/dev/tty', FS.makedev(5, 0)); FS.mkdev('/dev/tty1', FS.makedev(6, 0)); const random_device = getRandomDevice(); FS.createDevice('/dev', 'random', random_device); FS.createDevice('/dev', 'urandom', random_device); FS.mkdir('/dev/shm'); FS.mkdir('/dev/shm/tmp') }, createSpecialDirectories: function () { FS.mkdir('/proc'); const proc_self = FS.mkdir('/proc/self'); FS.mkdir('/proc/self/fd'); FS.mount({ mount: function () { const node = FS.createNode(proc_self, 'fd', 16384 | 511, 73); node.node_ops = { lookup: function (parent, name) { const fd = +name; const stream = FS.getStream(fd); if (!stream) throw new FS.ErrnoError(8); const ret = { parent: null, mount: { mountpoint: 'fake' }, node_ops: { readlink: function () { return stream.path } } }; ret.parent = ret; return ret } }; return node } }, {}, '/proc/self/fd') }, createStandardStreams: function () { if (Module.stdin) { FS.createDevice('/dev', 'stdin', Module.stdin) } else { FS.symlink('/dev/tty', '/dev/stdin') } if (Module.stdout) { FS.createDevice('/dev', 'stdout', null, Module.stdout) } else { FS.symlink('/dev/tty', '/dev/stdout') } if (Module.stderr) { FS.createDevice('/dev', 'stderr', null, Module.stderr) } else { FS.symlink('/dev/tty1', '/dev/stderr') } const stdin = FS.open('/dev/stdin', 0); const stdout = FS.open('/dev/stdout', 1); const stderr = FS.open('/dev/stderr', 1) }, ensureErrnoError: function () { if (FS.ErrnoError) return; FS.ErrnoError = function ErrnoError (errno, node) { this.node = node; this.setErrno = function (errno) { this.errno = errno }; this.setErrno(errno); this.message = 'FS error' }; FS.ErrnoError.prototype = new Error(); FS.ErrnoError.prototype.constructor = FS.ErrnoError; [44].forEach(function (code) { FS.genericErrors[code] = new FS.ErrnoError(code); FS.genericErrors[code].stack = '<generic error, no stack>' }) }, staticInit: function () { FS.ensureErrnoError(); FS.nameTable = new Array(4096); FS.mount(MEMFS, {}, '/'); FS.createDefaultDirectories(); FS.createDefaultDevices(); FS.createSpecialDirectories(); FS.filesystems = { MEMFS } }, init: function (input, output, error) { FS.init.initialized = true; FS.ensureErrnoError(); Module.stdin = input || Module.stdin; Module.stdout = output || Module.stdout; Module.stderr = error || Module.stderr; FS.createStandardStreams() }, quit: function () { FS.init.initialized = false; const fflush = Module._fflush; if (fflush)fflush(0); for (let i = 0; i < FS.streams.length; i++) { const stream = FS.streams[i]; if (!stream) { continue }FS.close(stream) } }, getMode: function (canRead, canWrite) { let mode = 0; if (canRead)mode |= 292 | 73; if (canWrite)mode |= 146; return mode }, findObject: function (path, dontResolveLastLink) { const ret = FS.analyzePath(path, dontResolveLastLink); if (ret.exists) { return ret.object } else { return null } }, analyzePath: function (path, dontResolveLastLink) { try { var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink }); path = lookup.path } catch (e) {} const ret = { isRoot: false, exists: false, error: 0, name: null, path: null, object: null, parentExists: false, parentPath: null, parentObject: null }; try { var lookup = FS.lookupPath(path, { parent: true }); ret.parentExists = true; ret.parentPath = lookup.path; ret.parentObject = lookup.node; ret.name = PATH.basename(path); lookup = FS.lookupPath(path, { follow: !dontResolveLastLink }); ret.exists = true; ret.path = lookup.path; ret.object = lookup.node; ret.name = lookup.node.name; ret.isRoot = lookup.path === '/' } catch (e) { ret.error = e.errno } return ret }, createPath: function (parent, path, canRead, canWrite) { parent = typeof parent === 'string' ? parent : FS.getPath(parent); const parts = path.split('/').reverse(); while (parts.length) { const part = parts.pop(); if (!part) continue; var current = PATH.join2(parent, part); try { FS.mkdir(current) } catch (e) {}parent = current } return current }, createFile: function (parent, name, properties, canRead, canWrite) { const path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name); const mode = FS.getMode(canRead, canWrite); return FS.create(path, mode) }, createDataFile: function (parent, name, data, canRead, canWrite, canOwn) { const path = name ? PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name) : parent; const mode = FS.getMode(canRead, canWrite); const node = FS.create(path, mode); if (data) { if (typeof data === 'string') { const arr = new Array(data.length); for (let i = 0, len = data.length; i < len; ++i)arr[i] = data.charCodeAt(i); data = arr }FS.chmod(node, mode | 146); const stream = FS.open(node, 577); FS.write(stream, data, 0, data.length, 0, canOwn); FS.close(stream); FS.chmod(node, mode) } return node }, createDevice: function (parent, name, input, output) { const path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name); const mode = FS.getMode(!!input, !!output); if (!FS.createDevice.major)FS.createDevice.major = 64; const dev = FS.makedev(FS.createDevice.major++, 0); FS.registerDevice(dev, { open: function (stream) { stream.seekable = false }, close: function (stream) { if (output && output.buffer && output.buffer.length) { output(10) } }, read: function (stream, buffer, offset, length, pos) { let bytesRead = 0; for (let i = 0; i < length; i++) { var result; try { result = input() } catch (e) { throw new FS.ErrnoError(29) } if (result === undefined && bytesRead === 0) { throw new FS.ErrnoError(6) } if (result === null || result === undefined) break; bytesRead++; buffer[offset + i] = result } if (bytesRead) { stream.node.timestamp = Date.now() } return bytesRead }, write: function (stream, buffer, offset, length, pos) { for (var i = 0; i < length; i++) { try { output(buffer[offset + i]) } catch (e) { throw new FS.ErrnoError(29) } } if (length) { stream.node.timestamp = Date.now() } return i } }); return FS.mkdev(path, mode, dev) }, forceLoadFile: function (obj) { if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true; if (typeof XMLHttpRequest !== 'undefined') { throw new Error('Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.') } else if (read_) { try { obj.contents = intArrayFromString(read_(obj.url), true); obj.usedBytes = obj.contents.length } catch (e) { throw new FS.ErrnoError(29) } } else { throw new Error('Cannot load without read() or XMLHttpRequest.') } }, createLazyFile: function (parent, name, url, canRead, canWrite) { function LazyUint8Array () { this.lengthKnown = false; this.chunks = [] }LazyUint8Array.prototype.get = function LazyUint8Array_get (idx) { if (idx > this.length - 1 || idx < 0) { return undefined } const chunkOffset = idx % this.chunkSize; const chunkNum = idx / this.chunkSize | 0; return this.getter(chunkNum)[chunkOffset] }; LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter (getter) { this.getter = getter }; LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength () { const xhr = new XMLHttpRequest(); xhr.open('HEAD', url, false); xhr.send(null); if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + '. Status: ' + xhr.status); let datalength = Number(xhr.getResponseHeader('Content-length')); let header; const hasByteServing = (header = xhr.getResponseHeader('Accept-Ranges')) && header === 'bytes'; const usesGzip = (header = xhr.getResponseHeader('Content-Encoding')) && header === 'gzip'; let chunkSize = 1024 * 1024; if (!hasByteServing)chunkSize = datalength; const doXHR = function (from, to) { if (from > to) throw new Error('invalid range (' + from + ', ' + to + ') or no bytes requested!'); if (to > datalength - 1) throw new Error('only ' + datalength + ' bytes available! programmer error!'); const xhr = new XMLHttpRequest(); xhr.open('GET', url, false); if (datalength !== chunkSize)xhr.setRequestHeader('Range', 'bytes=' + from + '-' + to); if (typeof Uint8Array !== 'undefined')xhr.responseType = 'arraybuffer'; if (xhr.overrideMimeType) { xhr.overrideMimeType('text/plain; charset=x-user-defined') }xhr.send(null); if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + '. Status: ' + xhr.status); if (xhr.response !== undefined) { return new Uint8Array(xhr.response || []) } else { return intArrayFromString(xhr.responseText || '', true) } }; const lazyArray = this; lazyArray.setDataGetter(function (chunkNum) { const start = chunkNum * chunkSize; let end = (chunkNum + 1) * chunkSize - 1; end = Math.min(end, datalength - 1); if (typeof lazyArray.chunks[chunkNum] === 'undefined') { lazyArray.chunks[chunkNum] = doXHR(start, end) } if (typeof lazyArray.chunks[chunkNum] === 'undefined') throw new Error('doXHR failed!'); return lazyArray.chunks[chunkNum] }); if (usesGzip || !datalength) { chunkSize = datalength = 1; datalength = this.getter(0).length; chunkSize = datalength; out('LazyFiles on gzip forces download of the whole file when length is accessed') } this._length = datalength; this._chunkSize = chunkSize; this.lengthKnown = true }; if (typeof XMLHttpRequest !== 'undefined') { if (!ENVIRONMENT_IS_WORKER) throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc'; const lazyArray = new LazyUint8Array(); Object.defineProperties(lazyArray, { length: { get: function () { if (!this.lengthKnown) { this.cacheLength() } return this._length } }, chunkSize: { get: function () { if (!this.lengthKnown) { this.cacheLength() } return this._chunkSize } } }); var properties = { isDevice: false, contents: lazyArray } } else { var properties = { isDevice: false, url } } const node = FS.createFile(parent, name, properties, canRead, canWrite); if (properties.contents) { node.contents = properties.contents } else if (properties.url) { node.contents = null; node.url = properties.url }Object.defineProperties(node, { usedBytes: { get: function () { return this.contents.length } } }); const stream_ops = {}; const keys = Object.keys(node.stream_ops); keys.forEach(function (key) { const fn = node.stream_ops[key]; stream_ops[key] = function forceLoadLazyFile () { FS.forceLoadFile(node); return fn.apply(null, arguments) } }); stream_ops.read = function stream_ops_read (stream, buffer, offset, length, position) { FS.forceLoadFile(node); const contents = stream.node.contents; if (position >= contents.length) return 0; const size = Math.min(contents.length - position, length); if (contents.slice) { for (var i = 0; i < size; i++) { buffer[offset + i] = contents[position + i] } } else { for (var i = 0; i < size; i++) { buffer[offset + i] = contents.get(position + i) } } return size }; node.stream_ops = stream_ops; return node }, createPreloadedFile: function (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) { Browser.init(); const fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent; const dep = getUniqueRunDependency('cp ' + fullname); function processData (byteArray) { function finish (byteArray) { if (preFinish)preFinish(); if (!dontCreateFile) { FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn) } if (onload)onload(); removeRunDependency(dep) } let handled = false; Module.preloadPlugins.forEach(function (plugin) { if (handled) return; if (plugin.canHandle(fullname)) { plugin.handle(byteArray, fullname, finish, function () { if (onerror)onerror(); removeRunDependency(dep) }); handled = true } }); if (!handled)finish(byteArray) }addRunDependency(dep); if (typeof url === 'string') { asyncLoad(url, function (byteArray) { processData(byteArray) }, onerror) } else { processData(url) } }, indexedDB: function () { return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB }, DB_NAME: function () { return 'EM_FS_' + window.location.pathname }, DB_VERSION: 20, DB_STORE_NAME: 'FILE_DATA', saveFilesToDB: function (paths, onload, onerror) { onload = onload || function () {}; onerror = onerror || function () {}; const indexedDB = FS.indexedDB(); try { var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION) } catch (e) { return onerror(e) }openRequest.onupgradeneeded = function openRequest_onupgradeneeded () { out('creating db'); const db = openRequest.result; db.createObjectStore(FS.DB_STORE_NAME) }; openRequest.onsuccess = function openRequest_onsuccess () { const db = openRequest.result; const transaction = db.transaction([FS.DB_STORE_NAME], 'readwrite'); const files = transaction.objectStore(FS.DB_STORE_NAME); let ok = 0; let fail = 0; const total = paths.length; function finish () { if (fail == 0)onload(); else onerror() }paths.forEach(function (path) { const putRequest = files.put(FS.analyzePath(path).object.contents, path); putRequest.onsuccess = function putRequest_onsuccess () { ok++; if (ok + fail == total)finish() }; putRequest.onerror = function putRequest_onerror () { fail++; if (ok + fail == total)finish() } }); transaction.onerror = onerror }; openRequest.onerror = onerror }, loadFilesFromDB: function (paths, onload, onerror) { onload = onload || function () {}; onerror = onerror || function () {}; const indexedDB = FS.indexedDB(); try { var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION) } catch (e) { return onerror(e) }openRequest.onupgradeneeded = onerror; openRequest.onsuccess = function openRequest_onsuccess () { const db = openRequest.result; try { var transaction = db.transaction([FS.DB_STORE_NAME], 'readonly') } catch (e) { onerror(e); return } const files = transaction.objectStore(FS.DB_STORE_NAME); let ok = 0; let fail = 0; const total = paths.length; function finish () { if (fail == 0)onload(); else onerror() }paths.forEach(function (path) { const getRequest = files.get(path); getRequest.onsuccess = function getRequest_onsuccess () { if (FS.analyzePath(path).exists) { FS.unlink(path) }FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true); ok++; if (ok + fail == total)finish() }; getRequest.onerror = function getRequest_onerror () { fail++; if (ok + fail == total)finish() } }); transaction.onerror = onerror }; openRequest.onerror = onerror } }; var SYSCALLS = { mappings: {}, DEFAULT_POLLMASK: 5, calculateAt: function (dirfd, path, allowEmpty) { if (path[0] === '/') { return path } let dir; if (dirfd === -100) { dir = FS.cwd() } else { const dirstream = FS.getStream(dirfd); if (!dirstream) throw new FS.ErrnoError(8); dir = dirstream.path } if (path.length == 0) { if (!allowEmpty) { throw new FS.ErrnoError(44) } return dir } return PATH.join2(dir, path) }, doStat: function (func, path, buf) { try { var stat = func(path) } catch (e) { if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) { return -54 } throw e }HEAP32[buf >> 2] = stat.dev; HEAP32[buf + 4 >> 2] = 0; HEAP32[buf + 8 >> 2] = stat.ino; HEAP32[buf + 12 >> 2] = stat.mode; HEAP32[buf + 16 >> 2] = stat.nlink; HEAP32[buf + 20 >> 2] = stat.uid; HEAP32[buf + 24 >> 2] = stat.gid; HEAP32[buf + 28 >> 2] = stat.rdev; HEAP32[buf + 32 >> 2] = 0; tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1]; HEAP32[buf + 48 >> 2] = 4096; HEAP32[buf + 52 >> 2] = stat.blocks; HEAP32[buf + 56 >> 2] = stat.atime.getTime() / 1e3 | 0; HEAP32[buf + 60 >> 2] = 0; HEAP32[buf + 64 >> 2] = stat.mtime.getTime() / 1e3 | 0; HEAP32[buf + 68 >> 2] = 0; HEAP32[buf + 72 >> 2] = stat.ctime.getTime() / 1e3 | 0; HEAP32[buf + 76 >> 2] = 0; tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 80 >> 2] = tempI64[0], HEAP32[buf + 84 >> 2] = tempI64[1]; return 0 }, doMsync: function (addr, stream, len, flags, offset) { const buffer = HEAPU8.slice(addr, addr + len); FS.msync(stream, buffer, offset, len, flags) }, doMkdir: function (path, mode) { path = PATH.normalize(path); if (path[path.length - 1] === '/')path = path.substr(0, path.length - 1); FS.mkdir(path, mode, 0); return 0 }, doMknod: function (path, mode, dev) { switch (mode & 61440) { case 32768:case 8192:case 24576:case 4096:case 49152:break; default:return -28 }FS.mknod(path, mode, dev); return 0 }, doReadlink: function (path, buf, bufsize) { if (bufsize <= 0) return -28; const ret = FS.readlink(path); const len = Math.min(bufsize, lengthBytesUTF8(ret)); const endChar = HEAP8[buf + len]; stringToUTF8(ret, buf, bufsize + 1); HEAP8[buf + len] = endChar; return len }, doAccess: function (path, amode) { if (amode & ~7) { return -28 } let node; const lookup = FS.lookupPath(path, { follow: true }); node = lookup.node; if (!node) { return -44 } let perms = ''; if (amode & 4)perms += 'r'; if (amode & 2)perms += 'w'; if (amode & 1)perms += 'x'; if (perms && FS.nodePermissions(node, perms)) { return -2 } return 0 }, doDup: function (path, flags, suggestFD) { const suggest = FS.getStream(suggestFD); if (suggest)FS.close(suggest); return FS.open(path, flags, 0, suggestFD, suggestFD).fd }, doReadv: function (stream, iov, iovcnt, offset) { let ret = 0; for (let i = 0; i < iovcnt; i++) { const ptr = HEAP32[iov + i * 8 >> 2]; const len = HEAP32[iov + (i * 8 + 4) >> 2]; const curr = FS.read(stream, HEAP8, ptr, len, offset); if (curr < 0) return -1; ret += curr; if (curr < len) break } return ret }, doWritev: function (stream, iov, iovcnt, offset) { let ret = 0; for (let i = 0; i < iovcnt; i++) { const ptr = HEAP32[iov + i * 8 >> 2]; const len = HEAP32[iov + (i * 8 + 4) >> 2]; const curr = FS.write(stream, HEAP8, ptr, len, offset); if (curr < 0) return -1; ret += curr } return ret }, varargs: undefined, get: function () { SYSCALLS.varargs += 4; const ret = HEAP32[SYSCALLS.varargs - 4 >> 2]; return ret }, getStr: function (ptr) { const ret = UTF8ToString(ptr); return ret }, getStreamFromFD: function (fd) { const stream = FS.getStream(fd); if (!stream) throw new FS.ErrnoError(8); return stream }, get64: function (low, high) { return low } }; function ___syscall_access (path, amode) { try { path = SYSCALLS.getStr(path); return SYSCALLS.doAccess(path, amode) } catch (e) { if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError))abort(e); return -e.errno } } function ___syscall_chmod (path, mode) { try { path = SYSCALLS.getStr(path); FS.chmod(path, mode); return 0 } catch (e) { if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError))abort(e); return -e.errno } } function ___syscall_fcntl64 (fd, cmd, varargs) { SYSCALLS.varargs = varargs; try { const stream = SYSCALLS.getStreamFromFD(fd); switch (cmd) { case 0:{ var arg = SYSCALLS.get(); if (arg < 0) { return -28 } let newStream; newStream = FS.open(stream.path, stream.flags, 0, arg); return newStream.fd } case 1:case 2:return 0; case 3:return stream.flags; case 4:{ var arg = SYSCALLS.get(); stream.flags |= arg; return 0 } case 12:{ var arg = SYSCALLS.get(); const offset = 0; HEAP16[arg + offset >> 1] = 2; return 0 } case 13:case 14:return 0; case 16:case 8:return -28; case 9:setErrNo(28); return -1; default:{ return -28 } } } catch (e) { if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError))abort(e); return -e.errno } } function ___syscall_fstat64 (fd, buf) { try { const stream = SYSCALLS.getStreamFromFD(fd); return SYSCALLS.doStat(FS.stat, stream.path, buf) } catch (e) { if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError))abort(e); return -e.errno } } function ___syscall_statfs64 (path, size, buf) { try { path = SYSCALLS.getStr(path); HEAP32[buf + 4 >> 2] = 4096; HEAP32[buf + 40 >> 2] = 4096; HEAP32[buf + 8 >> 2] = 1e6; HEAP32[buf + 12 >> 2] = 5e5; HEAP32[buf + 16 >> 2] = 5e5; HEAP32[buf + 20 >> 2] = FS.nextInode; HEAP32[buf + 24 >> 2] = 1e6; HEAP32[buf + 28 >> 2] = 42; HEAP32[buf + 44 >> 2] = 2; HEAP32[buf + 36 >> 2] = 255; return 0 } catch (e) { if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError))abort(e); return -e.errno } } function ___syscall_fstatfs64 (fd, size, buf) { try { const stream = SYSCALLS.getStreamFromFD(fd); return ___syscall_statfs64(0, size, buf) } catch (e) { if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError))abort(e); return -e.errno } } function ___syscall_getcwd (buf, size) { try { if (size === 0) return -28; const cwd = FS.cwd(); const cwdLengthInBytes = lengthBytesUTF8(cwd); if (size < cwdLengthInBytes + 1) return -68; stringToUTF8(cwd, buf, size); return buf } catch (e) { if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError))abort(e); return -e.errno } } function ___syscall_getdents64 (fd, dirp, count) { try { const stream = SYSCALLS.getStreamFromFD(fd); if (!stream.getdents) { stream.getdents = FS.readdir(stream.path) } const struct_size = 280; let pos = 0; const off = FS.llseek(stream, 0, 1); let idx = Math.floor(off / struct_size); while (idx < stream.getdents.length && pos + struct_size <= count) { var id; var type; const name = stream.getdents[idx]; if (name === '.') { id = stream.id; type = 4 } else if (name === '..') { id = FS.lookupPath(stream.path, { parent: true }).id; type = 4 } else { const child = FS.lookupNode(stream, name); id = child.id; type = FS.isChrdev(child.mode) ? 2 : FS.isDir(child.mode) ? 4 : FS.isLink(child.mode) ? 10 : 8 }tempI64 = [id >>> 0, (tempDouble = id, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[dirp + pos >> 2] = tempI64[0], HEAP32[dirp + pos + 4 >> 2] = tempI64[1]; tempI64 = [(idx + 1) * struct_size >>> 0, (tempDouble = (idx + 1) * struct_size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[dirp + pos + 8 >> 2] = tempI64[0], HEAP32[dirp + pos + 12 >> 2] = tempI64[1]; HEAP16[dirp + pos + 16 >> 1] = 280; HEAP8[dirp + pos + 18 >> 0] = type; stringToUTF8(name, dirp + pos + 19, 256); pos += struct_size; idx += 1 }FS.llseek(stream, idx * struct_size, 0); return pos } catch (e) { if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError))abort(e); return -e.errno } } function ___syscall_ioctl (fd, op, varargs) { SYSCALLS.varargs = varargs; try { const stream = SYSCALLS.getStreamFromFD(fd); switch (op) { case 21509:case 21505:{ if (!stream.tty) return -59; return 0 } case 21510:case 21511:case 21512:case 21506:case 21507:case 21508:{ if (!stream.tty) return -59; return 0 } case 21519:{ if (!stream.tty) return -59; var argp = SYSCALLS.get(); HEAP32[argp >> 2] = 0; return 0 } case 21520:{ if (!stream.tty) return -59; return -28 } case 21531:{ var argp = SYSCALLS.get(); return FS.ioctl(stream, op, argp) } case 21523:{ if (!stream.tty) return -59; return 0 } case 21524:{ if (!stream.tty) return -59; return 0 } default:abort('bad ioctl syscall ' + op) } } catch (e) { if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError))abort(e); return -e.errno } } function ___syscall_lstat64 (path, buf) { try { path = SYSCALLS.getStr(path); return SYSCALLS.doStat(FS.lstat, path, buf) } catch (e) { if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError))abort(e); return -e.errno } } function ___syscall_mkdir (path, mode) { try { path = SYSCALLS.getStr(path); return SYSCALLS.doMkdir(path, mode) } catch (e) { if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError))abort(e); return -e.errno } } function ___syscall_open (path, flags, varargs) { SYSCALLS.varargs = varargs; try { const pathname = SYSCALLS.getStr(path); const mode = varargs ? SYSCALLS.get() : 0; const stream = FS.open(pathname, flags, mode); return stream.fd } catch (e) { if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError))abort(e); return -e.errno } } function ___syscall_readlink (path, buf, bufsize) { try { path = SYSCALLS.getStr(path); return SYSCALLS.doReadlink(path, buf, bufsize) } catch (e) { if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError))abort(e); return -e.errno } } function ___syscall_rename (old_path, new_path) { try { old_path = SYSCALLS.getStr(old_path); new_path = SYSCALLS.getStr(new_path); FS.rename(old_path, new_path); return 0 } catch (e) { if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError))abort(e); return -e.errno } } function ___syscall_rmdir (path) { try { path = SYSCALLS.getStr(path); FS.rmdir(path); return 0 } catch (e) { if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError))abort(e); return -e.errno } } function ___syscall_stat64 (path, buf) { try { path = SYSCALLS.getStr(path); return SYSCALLS.doStat(FS.stat, path, buf) } catch (e) { if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError))abort(e); return -e.errno } } function ___syscall_symlink (target, linkpath) { try { target = SYSCALLS.getStr(target); linkpath = SYSCALLS.getStr(linkpath); FS.symlink(target, linkpath); return 0 } catch (e) { if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError))abort(e); return -e.errno } } function ___syscall_unlink (path) { try { path = SYSCALLS.getStr(path); FS.unlink(path); return 0 } catch (e) { if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError))abort(e); return -e.errno } } function __emscripten_throw_longjmp () { throw 'longjmp' } function _abort () { abort('') } function _emscripten_get_heap_max () { return 2147483648 } function _emscripten_memcpy_big (dest, src, num) { HEAPU8.copyWithin(dest, src, src + num) } function emscripten_realloc_buffer (size) { try { wasmMemory.grow(size - buffer.byteLength + 65535 >>> 16); updateGlobalBufferAndViews(wasmMemory.buffer); return 1 } catch (e) {} } function _emscripten_resize_heap (requestedSize) { const oldSize = HEAPU8.length; requestedSize = requestedSize >>> 0; const maxHeapSize = 2147483648; if (requestedSize > maxHeapSize) { return false } for (let cutDown = 1; cutDown <= 4; cutDown *= 2) { let overGrownHeapSize = oldSize * (1 + 0.2 / cutDown); overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296); const newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536)); const replacement = emscripten_realloc_buffer(newSize); if (replacement) { return true } } return false } const ENV = {}; function getExecutableName () { return thisProgram || './this.program' } function getEnvStrings () { if (!getEnvStrings.strings) { const lang = (typeof navigator === 'object' && navigator.languages && navigator.languages[0] || 'C').replace('-', '_') + '.UTF-8'; const env = { USER: 'web_user', LOGNAME: 'web_user', PATH: '/', PWD: '/', HOME: '/home/web_user', LANG: lang, _: getExecutableName() }; for (var x in ENV) { if (ENV[x] === undefined) delete env[x]; else env[x] = ENV[x] } const strings = []; for (var x in env) { strings.push(x + '=' + env[x]) }getEnvStrings.strings = strings } return getEnvStrings.strings } function _environ_get (__environ, environ_buf) { let bufSize = 0; getEnvStrings().forEach(function (string, i) { const ptr = environ_buf + bufSize; HEAP32[__environ + i * 4 >> 2] = ptr; writeAsciiToMemory(string, ptr); bufSize += string.length + 1 }); return 0 } function _environ_sizes_get (penviron_count, penviron_buf_size) { const strings = getEnvStrings(); HEAP32[penviron_count >> 2] = strings.length; let bufSize = 0; strings.forEach(function (string) { bufSize += string.length + 1 }); HEAP32[penviron_buf_size >> 2] = bufSize; return 0 } function _exit (status) { exit(status) } function _fd_close (fd) { try { const stream = SYSCALLS.getStreamFromFD(fd); FS.close(stream); return 0 } catch (e) { if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError))abort(e); return e.errno } } function _fd_read (fd, iov, iovcnt, pnum) { try { const stream = SYSCALLS.getStreamFromFD(fd); const num = SYSCALLS.doReadv(stream, iov, iovcnt); HEAP32[pnum >> 2] = num; return 0 } catch (e) { if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError))abort(e); return e.errno } } function _fd_seek (fd, offset_low, offset_high, whence, newOffset) { try { const stream = SYSCALLS.getStreamFromFD(fd); const HIGH_OFFSET = 4294967296; const offset = offset_high * HIGH_OFFSET + (offset_low >>> 0); const DOUBLE_LIMIT = 9007199254740992; if (offset <= -DOUBLE_LIMIT || offset >= DOUBLE_LIMIT) { return -61 }FS.llseek(stream, offset, whence); tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[newOffset >> 2] = tempI64[0], HEAP32[newOffset + 4 >> 2] = tempI64[1]; if (stream.getdents && offset === 0 && whence === 0)stream.getdents = null; return 0 } catch (e) { if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError))abort(e); return e.errno } } function _fd_write (fd, iov, iovcnt, pnum) { try { const stream = SYSCALLS.getStreamFromFD(fd); const num = SYSCALLS.doWritev(stream, iov, iovcnt); HEAP32[pnum >> 2] = num; return 0 } catch (e) { if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError))abort(e); return e.errno } } function _getTempRet0 () { return getTempRet0() } function _gettimeofday (ptr) { const now = Date.now(); HEAP32[ptr >> 2] = now / 1e3 | 0; HEAP32[ptr + 4 >> 2] = now % 1e3 * 1e3 | 0; return 0 } function _setTempRet0 (val) { setTempRet0(val) } function _time (ptr) { const ret = Date.now() / 1e3 | 0; if (ptr) { HEAP32[ptr >> 2] = ret } return ret } const FSNode = function (parent, name, mode, rdev) { if (!parent) { parent = this } this.parent = parent; this.mount = parent.mount; this.mounted = null; this.id = FS.nextInode++; this.name = name; this.mode = mode; this.node_ops = {}; this.stream_ops = {}; this.rdev = rdev }; const readMode = 292 | 73; const writeMode = 146; Object.defineProperties(FSNode.prototype, { read: { get: function () { return (this.mode & readMode) === readMode }, set: function (val) { val ? this.mode |= readMode : this.mode &= ~readMode } }, write: { get: function () { return (this.mode & writeMode) === writeMode }, set: function (val) { val ? this.mode |= writeMode : this.mode &= ~writeMode } }, isFolder: { get: function () { return FS.isDir(this.mode) } }, isDevice: { get: function () { return FS.isChrdev(this.mode) } } }); FS.FSNode = FSNode; FS.staticInit(); Module.FS_createPath = FS.createPath; Module.FS_createDataFile = FS.createDataFile; Module.FS_createPreloadedFile = FS.createPreloadedFile; Module.FS_createLazyFile = FS.createLazyFile; Module.FS_createDevice = FS.createDevice; Module.FS_unlink = FS.unlink; function intArrayFromString (stringy, dontAddNull, length) { const len = length > 0 ? length : lengthBytesUTF8(stringy) + 1; const u8array = new Array(len); const numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length); if (dontAddNull)u8array.length = numBytesWritten; return u8array } var asmLibraryArg = { a: ___assert_fail, w: ___clock_gettime, y: ___syscall_access, L: ___syscall_chmod, c: ___syscall_fcntl64, G: ___syscall_fstat64, J: ___syscall_fstatfs64, z: ___syscall_getcwd, v: ___syscall_getdents64, E: ___syscall_ioctl, I: ___syscall_lstat64, K: ___syscall_mkdir, j: ___syscall_open, A: ___syscall_readlink, F: ___syscall_rename, B: ___syscall_rmdir, H: ___syscall_stat64, C: ___syscall_symlink, D: ___syscall_unlink, s: __emscripten_throw_longjmp, k: _abort, x: _emscripten_get_heap_max, f: _emscripten_get_now, q: _emscripten_memcpy_big, r: _emscripten_resize_heap, t: _environ_get, u: _environ_sizes_get, g: _exit, e: _fd_close, m: _fd_read, p: _fd_seek, i: _fd_write, d: _getTempRet0, M: _gettimeofday, o: invoke_iii, l: invoke_iiii, n: invoke_iiiii, b: _setTempRet0, h: _time }; const asm = createWasm(); var ___wasm_call_ctors = Module.___wasm_call_ctors = function () { return (___wasm_call_ctors = Module.___wasm_call_ctors = Module.asm.O).apply(null, arguments) }; var _main = Module._main = function () { return (_main = Module._main = Module.asm.P).apply(null, arguments) }; var _emscripten_bind_VoidPtr___destroy___0 = Module._emscripten_bind_VoidPtr___destroy___0 = function () { return (_emscripten_bind_VoidPtr___destroy___0 = Module._emscripten_bind_VoidPtr___destroy___0 = Module.asm.Q).apply(null, arguments) }; var _emscripten_bind_ASS_Style_get_Name_0 = Module._emscripten_bind_ASS_Style_get_Name_0 = function () { return (_emscripten_bind_ASS_Style_get_Name_0 = Module._emscripten_bind_ASS_Style_get_Name_0 = Module.asm.R).apply(null, arguments) }; var _emscripten_bind_ASS_Style_set_Name_1 = Module._emscripten_bind_ASS_Style_set_Name_1 = function () { return (_emscripten_bind_ASS_Style_set_Name_1 = Module._emscripten_bind_ASS_Style_set_Name_1 = Module.asm.S).apply(null, arguments) }; var _emscripten_bind_ASS_Style_get_FontName_0 = Module._emscripten_bind_ASS_Style_get_FontName_0 = function () { return (_emscripten_bind_ASS_Style_get_FontName_0 = Module._emscripten_bind_ASS_Style_get_FontName_0 = Module.asm.T).apply(null, arguments) }; var _emscripten_bind_ASS_Style_set_FontName_1 = Module._emscripten_bind_ASS_Style_set_FontName_1 = function () { return (_emscripten_bind_ASS_Style_set_FontName_1 = Module._emscripten_bind_ASS_Style_set_FontName_1 = Module.asm.U).apply(null, arguments) }; var _emscripten_bind_ASS_Style_get_FontSize_0 = Module._emscripten_bind_ASS_Style_get_FontSize_0 = function () { return (_emscripten_bind_ASS_Style_get_FontSize_0 = Module._emscripten_bind_ASS_Style_get_FontSize_0 = Module.asm.V).apply(null, arguments) }; var _emscripten_bind_ASS_Style_set_FontSize_1 = Module._emscripten_bind_ASS_Style_set_FontSize_1 = function () { return (_emscripten_bind_ASS_Style_set_FontSize_1 = Module._emscripten_bind_ASS_Style_set_FontSize_1 = Module.asm.W).apply(null, arguments) }; var _emscripten_bind_ASS_Style_get_PrimaryColour_0 = Module._emscripten_bind_ASS_Style_get_PrimaryColour_0 = function () { return (_emscripten_bind_ASS_Style_get_PrimaryColour_0 = Module._emscripten_bind_ASS_Style_get_PrimaryColour_0 = Module.asm.X).apply(null, arguments) }; var _emscripten_bind_ASS_Style_set_PrimaryColour_1 = Module._emscripten_bind_ASS_Style_set_PrimaryColour_1 = function () { return (_emscripten_bind_ASS_Style_set_PrimaryColour_1 = Module._emscripten_bind_ASS_Style_set_PrimaryColour_1 = Module.asm.Y).apply(null, arguments) }; var _emscripten_bind_ASS_Style_get_SecondaryColour_0 = Module._emscripten_bind_ASS_Style_get_SecondaryColour_0 = function () { return (_emscripten_bind_ASS_Style_get_SecondaryColour_0 = Module._emscripten_bind_ASS_Style_get_SecondaryColour_0 = Module.asm.Z).apply(null, arguments) }; var _emscripten_bind_ASS_Style_set_SecondaryColour_1 = Module._emscripten_bind_ASS_Style_set_SecondaryColour_1 = function () { return (_emscripten_bind_ASS_Style_set_SecondaryColour_1 = Module._emscripten_bind_ASS_Style_set_SecondaryColour_1 = Module.asm._).apply(null, arguments) }; var _emscripten_bind_ASS_Style_get_OutlineColour_0 = Module._emscripten_bind_ASS_Style_get_OutlineColour_0 = function () { return (_emscripten_bind_ASS_Style_get_OutlineColour_0 = Module._emscripten_bind_ASS_Style_get_OutlineColour_0 = Module.asm.$).apply(null, arguments) }; var _emscripten_bind_ASS_Style_set_OutlineColour_1 = Module._emscripten_bind_ASS_Style_set_OutlineColour_1 = function () { return (_emscripten_bind_ASS_Style_set_OutlineColour_1 = Module._emscripten_bind_ASS_Style_set_OutlineColour_1 = Module.asm.aa).apply(null, arguments) }; var _emscripten_bind_ASS_Style_get_BackColour_0 = Module._emscripten_bind_ASS_Style_get_BackColour_0 = function () { return (_emscripten_bind_ASS_Style_get_BackColour_0 = Module._emscripten_bind_ASS_Style_get_BackColour_0 = Module.asm.ba).apply(null, arguments) }; var _emscripten_bind_ASS_Style_set_BackColour_1 = Module._emscripten_bind_ASS_Style_set_BackColour_1 = function () { return (_emscripten_bind_ASS_Style_set_BackColour_1 = Module._emscripten_bind_ASS_Style_set_BackColour_1 = Module.asm.ca).apply(null, arguments) }; var _emscripten_bind_ASS_Style_get_Bold_0 = Module._emscripten_bind_ASS_Style_get_Bold_0 = function () { return (_emscripten_bind_ASS_Style_get_Bold_0 = Module._emscripten_bind_ASS_Style_get_Bold_0 = Module.asm.da).apply(null, arguments) }; var _emscripten_bind_ASS_Style_set_Bold_1 = Module._emscripten_bind_ASS_Style_set_Bold_1 = function () { return (_emscripten_bind_ASS_Style_set_Bold_1 = Module._emscripten_bind_ASS_Style_set_Bold_1 = Module.asm.ea).apply(null, arguments) }; var _emscripten_bind_ASS_Style_get_Italic_0 = Module._emscripten_bind_ASS_Style_get_Italic_0 = function () { return (_emscripten_bind_ASS_Style_get_Italic_0 = Module._emscripten_bind_ASS_Style_get_Italic_0 = Module.asm.fa).apply(null, arguments) }; var _emscripten_bind_ASS_Style_set_Italic_1 = Module._emscripten_bind_ASS_Style_set_Italic_1 = function () { return (_emscripten_bind_ASS_Style_set_Italic_1 = Module._emscripten_bind_ASS_Style_set_Italic_1 = Module.asm.ga).apply(null, arguments) }; var _emscripten_bind_ASS_Style_get_Underline_0 = Module._emscripten_bind_ASS_Style_get_Underline_0 = function () { return (_emscripten_bind_ASS_Style_get_Underline_0 = Module._emscripten_bind_ASS_Style_get_Underline_0 = Module.asm.ha).apply(null, arguments) }; var _emscripten_bind_ASS_Style_set_Underline_1 = Module._emscripten_bind_ASS_Style_set_Underline_1 = function () { return (_emscripten_bind_ASS_Style_set_Underline_1 = Module._emscripten_bind_ASS_Style_set_Underline_1 = Module.asm.ia).apply(null, arguments) }; var _emscripten_bind_ASS_Style_get_StrikeOut_0 = Module._emscripten_bind_ASS_Style_get_StrikeOut_0 = function () { return (_emscripten_bind_ASS_Style_get_StrikeOut_0 = Module._emscripten_bind_ASS_Style_get_StrikeOut_0 = Module.asm.ja).apply(null, arguments) }; var _emscripten_bind_ASS_Style_set_StrikeOut_1 = Module._emscripten_bind_ASS_Style_set_StrikeOut_1 = function () { return (_emscripten_bind_ASS_Style_set_StrikeOut_1 = Module._emscripten_bind_ASS_Style_set_StrikeOut_1 = Module.asm.ka).apply(null, arguments) }; var _emscripten_bind_ASS_Style_get_ScaleX_0 = Module._emscripten_bind_ASS_Style_get_ScaleX_0 = function () { return (_emscripten_bind_ASS_Style_get_ScaleX_0 = Module._emscripten_bind_ASS_Style_get_ScaleX_0 = Module.asm.la).apply(null, arguments) }; var _emscripten_bind_ASS_Style_set_ScaleX_1 = Module._emscripten_bind_ASS_Style_set_ScaleX_1 = function () { return (_emscripten_bind_ASS_Style_set_ScaleX_1 = Module._emscripten_bind_ASS_Style_set_ScaleX_1 = Module.asm.ma).apply(null, arguments) }; var _emscripten_bind_ASS_Style_get_ScaleY_0 = Module._emscripten_bind_ASS_Style_get_ScaleY_0 = function () { return (_emscripten_bind_ASS_Style_get_ScaleY_0 = Module._emscripten_bind_ASS_Style_get_ScaleY_0 = Module.asm.na).apply(null, arguments) }; var _emscripten_bind_ASS_Style_set_ScaleY_1 = Module._emscripten_bind_ASS_Style_set_ScaleY_1 = function () { return (_emscripten_bind_ASS_Style_set_ScaleY_1 = Module._emscripten_bind_ASS_Style_set_ScaleY_1 = Module.asm.oa).apply(null, arguments) }; var _emscripten_bind_ASS_Style_get_Spacing_0 = Module._emscripten_bind_ASS_Style_get_Spacing_0 = function () { return (_emscripten_bind_ASS_Style_get_Spacing_0 = Module._emscripten_bind_ASS_Style_get_Spacing_0 = Module.asm.pa).apply(null, arguments) }; var _emscripten_bind_ASS_Style_set_Spacing_1 = Module._emscripten_bind_ASS_Style_set_Spacing_1 = function () { return (_emscripten_bind_ASS_Style_set_Spacing_1 = Module._emscripten_bind_ASS_Style_set_Spacing_1 = Module.asm.qa).apply(null, arguments) }; var _emscripten_bind_ASS_Style_get_Angle_0 = Module._emscripten_bind_ASS_Style_get_Angle_0 = function () { return (_emscripten_bind_ASS_Style_get_Angle_0 = Module._emscripten_bind_ASS_Style_get_Angle_0 = Module.asm.ra).apply(null, arguments) }; var _emscripten_bind_ASS_Style_set_Angle_1 = Module._emscripten_bind_ASS_Style_set_Angle_1 = function () { return (_emscripten_bind_ASS_Style_set_Angle_1 = Module._emscripten_bind_ASS_Style_set_Angle_1 = Module.asm.sa).apply(null, arguments) }; var _emscripten_bind_ASS_Style_get_BorderStyle_0 = Module._emscripten_bind_ASS_Style_get_BorderStyle_0 = function () { return (_emscripten_bind_ASS_Style_get_BorderStyle_0 = Module._emscripten_bind_ASS_Style_get_BorderStyle_0 = Module.asm.ta).apply(null, arguments) }; var _emscripten_bind_ASS_Style_set_BorderStyle_1 = Module._emscripten_bind_ASS_Style_set_BorderStyle_1 = function () { return (_emscripten_bind_ASS_Style_set_BorderStyle_1 = Module._emscripten_bind_ASS_Style_set_BorderStyle_1 = Module.asm.ua).apply(null, arguments) }; var _emscripten_bind_ASS_Style_get_Outline_0 = Module._emscripten_bind_ASS_Style_get_Outline_0 = function () { return (_emscripten_bind_ASS_Style_get_Outline_0 = Module._emscripten_bind_ASS_Style_get_Outline_0 = Module.asm.va).apply(null, arguments) }; var _emscripten_bind_ASS_Style_set_Outline_1 = Module._emscripten_bind_ASS_Style_set_Outline_1 = function () { return (_emscripten_bind_ASS_Style_set_Outline_1 = Module._emscripten_bind_ASS_Style_set_Outline_1 = Module.asm.wa).apply(null, arguments) }; var _emscripten_bind_ASS_Style_get_Shadow_0 = Module._emscripten_bind_ASS_Style_get_Shadow_0 = function () { return (_emscripten_bind_ASS_Style_get_Shadow_0 = Module._emscripten_bind_ASS_Style_get_Shadow_0 = Module.asm.xa).apply(null, arguments) }; var _emscripten_bind_ASS_Style_set_Shadow_1 = Module._emscripten_bind_ASS_Style_set_Shadow_1 = function () { return (_emscripten_bind_ASS_Style_set_Shadow_1 = Module._emscripten_bind_ASS_Style_set_Shadow_1 = Module.asm.ya).apply(null, arguments) }; var _emscripten_bind_ASS_Style_get_Alignment_0 = Module._emscripten_bind_ASS_Style_get_Alignment_0 = function () { return (_emscripten_bind_ASS_Style_get_Alignment_0 = Module._emscripten_bind_ASS_Style_get_Alignment_0 = Module.asm.za).apply(null, arguments) }; var _emscripten_bind_ASS_Style_set_Alignment_1 = Module._emscripten_bind_ASS_Style_set_Alignment_1 = function () { return (_emscripten_bind_ASS_Style_set_Alignment_1 = Module._emscripten_bind_ASS_Style_set_Alignment_1 = Module.asm.Aa).apply(null, arguments) }; var _emscripten_bind_ASS_Style_get_MarginL_0 = Module._emscripten_bind_ASS_Style_get_MarginL_0 = function () { return (_emscripten_bind_ASS_Style_get_MarginL_0 = Module._emscripten_bind_ASS_Style_get_MarginL_0 = Module.asm.Ba).apply(null, arguments) }; var _emscripten_bind_ASS_Style_set_MarginL_1 = Module._emscripten_bind_ASS_Style_set_MarginL_1 = function () { return (_emscripten_bind_ASS_Style_set_MarginL_1 = Module._emscripten_bind_ASS_Style_set_MarginL_1 = Module.asm.Ca).apply(null, arguments) }; var _emscripten_bind_ASS_Style_get_MarginR_0 = Module._emscripten_bind_ASS_Style_get_MarginR_0 = function () { return (_emscripten_bind_ASS_Style_get_MarginR_0 = Module._emscripten_bind_ASS_Style_get_MarginR_0 = Module.asm.Da).apply(null, arguments) }; var _emscripten_bind_ASS_Style_set_MarginR_1 = Module._emscripten_bind_ASS_Style_set_MarginR_1 = function () { return (_emscripten_bind_ASS_Style_set_MarginR_1 = Module._emscripten_bind_ASS_Style_set_MarginR_1 = Module.asm.Ea).apply(null, arguments) }; var _emscripten_bind_ASS_Style_get_MarginV_0 = Module._emscripten_bind_ASS_Style_get_MarginV_0 = function () { return (_emscripten_bind_ASS_Style_get_MarginV_0 = Module._emscripten_bind_ASS_Style_get_MarginV_0 = Module.asm.Fa).apply(null, arguments) }; var _emscripten_bind_ASS_Style_set_MarginV_1 = Module._emscripten_bind_ASS_Style_set_MarginV_1 = function () { return (_emscripten_bind_ASS_Style_set_MarginV_1 = Module._emscripten_bind_ASS_Style_set_MarginV_1 = Module.asm.Ga).apply(null, arguments) }; var _emscripten_bind_ASS_Style_get_Encoding_0 = Module._emscripten_bind_ASS_Style_get_Encoding_0 = function () { return (_emscripten_bind_ASS_Style_get_Encoding_0 = Module._emscripten_bind_ASS_Style_get_Encoding_0 = Module.asm.Ha).apply(null, arguments) }; var _emscripten_bind_ASS_Style_set_Encoding_1 = Module._emscripten_bind_ASS_Style_set_Encoding_1 = function () { return (_emscripten_bind_ASS_Style_set_Encoding_1 = Module._emscripten_bind_ASS_Style_set_Encoding_1 = Module.asm.Ia).apply(null, arguments) }; var _emscripten_bind_ASS_Style_get_treat_fontname_as_pattern_0 = Module._emscripten_bind_ASS_Style_get_treat_fontname_as_pattern_0 = function () { return (_emscripten_bind_ASS_Style_get_treat_fontname_as_pattern_0 = Module._emscripten_bind_ASS_Style_get_treat_fontname_as_pattern_0 = Module.asm.Ja).apply(null, arguments) }; var _emscripten_bind_ASS_Style_set_treat_fontname_as_pattern_1 = Module._emscripten_bind_ASS_Style_set_treat_fontname_as_pattern_1 = function () { return (_emscripten_bind_ASS_Style_set_treat_fontname_as_pattern_1 = Module._emscripten_bind_ASS_Style_set_treat_fontname_as_pattern_1 = Module.asm.Ka).apply(null, arguments) }; var _emscripten_bind_ASS_Style_get_Blur_0 = Module._emscripten_bind_ASS_Style_get_Blur_0 = function () { return (_emscripten_bind_ASS_Style_get_Blur_0 = Module._emscripten_bind_ASS_Style_get_Blur_0 = Module.asm.La).apply(null, arguments) }; var _emscripten_bind_ASS_Style_set_Blur_1 = Module._emscripten_bind_ASS_Style_set_Blur_1 = function () { return (_emscripten_bind_ASS_Style_set_Blur_1 = Module._emscripten_bind_ASS_Style_set_Blur_1 = Module.asm.Ma).apply(null, arguments) }; var _emscripten_bind_ASS_Style_get_Justify_0 = Module._emscripten_bind_ASS_Style_get_Justify_0 = function () { return (_emscripten_bind_ASS_Style_get_Justify_0 = Module._emscripten_bind_ASS_Style_get_Justify_0 = Module.asm.Na).apply(null, arguments) }; var _emscripten_bind_ASS_Style_set_Justify_1 = Module._emscripten_bind_ASS_Style_set_Justify_1 = function () { return (_emscripten_bind_ASS_Style_set_Justify_1 = Module._emscripten_bind_ASS_Style_set_Justify_1 = Module.asm.Oa).apply(null, arguments) }; var _emscripten_bind_ASS_Event_get_Start_0 = Module._emscripten_bind_ASS_Event_get_Start_0 = function () { return (_emscripten_bind_ASS_Event_get_Start_0 = Module._emscripten_bind_ASS_Event_get_Start_0 = Module.asm.Pa).apply(null, arguments) }; var _emscripten_bind_ASS_Event_set_Start_1 = Module._emscripten_bind_ASS_Event_set_Start_1 = function () { return (_emscripten_bind_ASS_Event_set_Start_1 = Module._emscripten_bind_ASS_Event_set_Start_1 = Module.asm.Qa).apply(null, arguments) }; var _emscripten_bind_ASS_Event_get_Duration_0 = Module._emscripten_bind_ASS_Event_get_Duration_0 = function () { return (_emscripten_bind_ASS_Event_get_Duration_0 = Module._emscripten_bind_ASS_Event_get_Duration_0 = Module.asm.Ra).apply(null, arguments) }; var _emscripten_bind_ASS_Event_set_Duration_1 = Module._emscripten_bind_ASS_Event_set_Duration_1 = function () { return (_emscripten_bind_ASS_Event_set_Duration_1 = Module._emscripten_bind_ASS_Event_set_Duration_1 = Module.asm.Sa).apply(null, arguments) }; var _emscripten_bind_ASS_Event_get_ReadOrder_0 = Module._emscripten_bind_ASS_Event_get_ReadOrder_0 = function () { return (_emscripten_bind_ASS_Event_get_ReadOrder_0 = Module._emscripten_bind_ASS_Event_get_ReadOrder_0 = Module.asm.Ta).apply(null, arguments) }; var _emscripten_bind_ASS_Event_set_ReadOrder_1 = Module._emscripten_bind_ASS_Event_set_ReadOrder_1 = function () { return (_emscripten_bind_ASS_Event_set_ReadOrder_1 = Module._emscripten_bind_ASS_Event_set_ReadOrder_1 = Module.asm.Ua).apply(null, arguments) }; var _emscripten_bind_ASS_Event_get_Layer_0 = Module._emscripten_bind_ASS_Event_get_Layer_0 = function () { return (_emscripten_bind_ASS_Event_get_Layer_0 = Module._emscripten_bind_ASS_Event_get_Layer_0 = Module.asm.Va).apply(null, arguments) }; var _emscripten_bind_ASS_Event_set_Layer_1 = Module._emscripten_bind_ASS_Event_set_Layer_1 = function () { return (_emscripten_bind_ASS_Event_set_Layer_1 = Module._emscripten_bind_ASS_Event_set_Layer_1 = Module.asm.Wa).apply(null, arguments) }; var _emscripten_bind_ASS_Event_get_Style_0 = Module._emscripten_bind_ASS_Event_get_Style_0 = function () { return (_emscripten_bind_ASS_Event_get_Style_0 = Module._emscripten_bind_ASS_Event_get_Style_0 = Module.asm.Xa).apply(null, arguments) }; var _emscripten_bind_ASS_Event_set_Style_1 = Module._emscripten_bind_ASS_Event_set_Style_1 = function () { return (_emscripten_bind_ASS_Event_set_Style_1 = Module._emscripten_bind_ASS_Event_set_Style_1 = Module.asm.Ya).apply(null, arguments) }; var _emscripten_bind_ASS_Event_get_Name_0 = Module._emscripten_bind_ASS_Event_get_Name_0 = function () { return (_emscripten_bind_ASS_Event_get_Name_0 = Module._emscripten_bind_ASS_Event_get_Name_0 = Module.asm.Za).apply(null, arguments) }; var _emscripten_bind_ASS_Event_set_Name_1 = Module._emscripten_bind_ASS_Event_set_Name_1 = function () { return (_emscripten_bind_ASS_Event_set_Name_1 = Module._emscripten_bind_ASS_Event_set_Name_1 = Module.asm._a).apply(null, arguments) }; var _emscripten_bind_ASS_Event_get_MarginL_0 = Module._emscripten_bind_ASS_Event_get_MarginL_0 = function () { return (_emscripten_bind_ASS_Event_get_MarginL_0 = Module._emscripten_bind_ASS_Event_get_MarginL_0 = Module.asm.$a).apply(null, arguments) }; var _emscripten_bind_ASS_Event_set_MarginL_1 = Module._emscripten_bind_ASS_Event_set_MarginL_1 = function () { return (_emscripten_bind_ASS_Event_set_MarginL_1 = Module._emscripten_bind_ASS_Event_set_MarginL_1 = Module.asm.ab).apply(null, arguments) }; var _emscripten_bind_ASS_Event_get_MarginR_0 = Module._emscripten_bind_ASS_Event_get_MarginR_0 = function () { return (_emscripten_bind_ASS_Event_get_MarginR_0 = Module._emscripten_bind_ASS_Event_get_MarginR_0 = Module.asm.bb).apply(null, arguments) }; var _emscripten_bind_ASS_Event_set_MarginR_1 = Module._emscripten_bind_ASS_Event_set_MarginR_1 = function () { return (_emscripten_bind_ASS_Event_set_MarginR_1 = Module._emscripten_bind_ASS_Event_set_MarginR_1 = Module.asm.cb).apply(null, arguments) }; var _emscripten_bind_ASS_Event_get_MarginV_0 = Module._emscripten_bind_ASS_Event_get_MarginV_0 = function () { return (_emscripten_bind_ASS_Event_get_MarginV_0 = Module._emscripten_bind_ASS_Event_get_MarginV_0 = Module.asm.db).apply(null, arguments) }; var _emscripten_bind_ASS_Event_set_MarginV_1 = Module._emscripten_bind_ASS_Event_set_MarginV_1 = function () { return (_emscripten_bind_ASS_Event_set_MarginV_1 = Module._emscripten_bind_ASS_Event_set_MarginV_1 = Module.asm.eb).apply(null, arguments) }; var _emscripten_bind_ASS_Event_get_Effect_0 = Module._emscripten_bind_ASS_Event_get_Effect_0 = function () { return (_emscripten_bind_ASS_Event_get_Effect_0 = Module._emscripten_bind_ASS_Event_get_Effect_0 = Module.asm.fb).apply(null, arguments) }; var _emscripten_bind_ASS_Event_set_Effect_1 = Module._emscripten_bind_ASS_Event_set_Effect_1 = function () { return (_emscripten_bind_ASS_Event_set_Effect_1 = Module._emscripten_bind_ASS_Event_set_Effect_1 = Module.asm.gb).apply(null, arguments) }; var _emscripten_bind_ASS_Event_get_Text_0 = Module._emscripten_bind_ASS_Event_get_Text_0 = function () { return (_emscripten_bind_ASS_Event_get_Text_0 = Module._emscripten_bind_ASS_Event_get_Text_0 = Module.asm.hb).apply(null, arguments) }; var _emscripten_bind_ASS_Event_set_Text_1 = Module._emscripten_bind_ASS_Event_set_Text_1 = function () { return (_emscripten_bind_ASS_Event_set_Text_1 = Module._emscripten_bind_ASS_Event_set_Text_1 = Module.asm.ib).apply(null, arguments) }; var _emscripten_bind_RenderResult_get_changed_0 = Module._emscripten_bind_RenderResult_get_changed_0 = function () { return (_emscripten_bind_RenderResult_get_changed_0 = Module._emscripten_bind_RenderResult_get_changed_0 = Module.asm.jb).apply(null, arguments) }; var _emscripten_bind_RenderResult_set_changed_1 = Module._emscripten_bind_RenderResult_set_changed_1 = function () { return (_emscripten_bind_RenderResult_set_changed_1 = Module._emscripten_bind_RenderResult_set_changed_1 = Module.asm.kb).apply(null, arguments) }; var _emscripten_bind_RenderResult_get_time_0 = Module._emscripten_bind_RenderResult_get_time_0 = function () { return (_emscripten_bind_RenderResult_get_time_0 = Module._emscripten_bind_RenderResult_get_time_0 = Module.asm.lb).apply(null, arguments) }; var _emscripten_bind_RenderResult_set_time_1 = Module._emscripten_bind_RenderResult_set_time_1 = function () { return (_emscripten_bind_RenderResult_set_time_1 = Module._emscripten_bind_RenderResult_set_time_1 = Module.asm.mb).apply(null, arguments) }; var _emscripten_bind_RenderResult_get_x_0 = Module._emscripten_bind_RenderResult_get_x_0 = function () { return (_emscripten_bind_RenderResult_get_x_0 = Module._emscripten_bind_RenderResult_get_x_0 = Module.asm.nb).apply(null, arguments) }; var _emscripten_bind_RenderResult_set_x_1 = Module._emscripten_bind_RenderResult_set_x_1 = function () { return (_emscripten_bind_RenderResult_set_x_1 = Module._emscripten_bind_RenderResult_set_x_1 = Module.asm.ob).apply(null, arguments) }; var _emscripten_bind_RenderResult_get_y_0 = Module._emscripten_bind_RenderResult_get_y_0 = function () { return (_emscripten_bind_RenderResult_get_y_0 = Module._emscripten_bind_RenderResult_get_y_0 = Module.asm.pb).apply(null, arguments) }; var _emscripten_bind_RenderResult_set_y_1 = Module._emscripten_bind_RenderResult_set_y_1 = function () { return (_emscripten_bind_RenderResult_set_y_1 = Module._emscripten_bind_RenderResult_set_y_1 = Module.asm.qb).apply(null, arguments) }; var _emscripten_bind_RenderResult_get_w_0 = Module._emscripten_bind_RenderResult_get_w_0 = function () { return (_emscripten_bind_RenderResult_get_w_0 = Module._emscripten_bind_RenderResult_get_w_0 = Module.asm.rb).apply(null, arguments) }; var _emscripten_bind_RenderResult_set_w_1 = Module._emscripten_bind_RenderResult_set_w_1 = function () { return (_emscripten_bind_RenderResult_set_w_1 = Module._emscripten_bind_RenderResult_set_w_1 = Module.asm.sb).apply(null, arguments) }; var _emscripten_bind_RenderResult_get_h_0 = Module._emscripten_bind_RenderResult_get_h_0 = function () { return (_emscripten_bind_RenderResult_get_h_0 = Module._emscripten_bind_RenderResult_get_h_0 = Module.asm.tb).apply(null, arguments) }; var _emscripten_bind_RenderResult_set_h_1 = Module._emscripten_bind_RenderResult_set_h_1 = function () { return (_emscripten_bind_RenderResult_set_h_1 = Module._emscripten_bind_RenderResult_set_h_1 = Module.asm.ub).apply(null, arguments) }; var _emscripten_bind_RenderResult_get_image_0 = Module._emscripten_bind_RenderResult_get_image_0 = function () { return (_emscripten_bind_RenderResult_get_image_0 = Module._emscripten_bind_RenderResult_get_image_0 = Module.asm.vb).apply(null, arguments) }; var _emscripten_bind_RenderResult_set_image_1 = Module._emscripten_bind_RenderResult_set_image_1 = function () { return (_emscripten_bind_RenderResult_set_image_1 = Module._emscripten_bind_RenderResult_set_image_1 = Module.asm.wb).apply(null, arguments) }; var _emscripten_bind_RenderResult_get_next_0 = Module._emscripten_bind_RenderResult_get_next_0 = function () { return (_emscripten_bind_RenderResult_get_next_0 = Module._emscripten_bind_RenderResult_get_next_0 = Module.asm.xb).apply(null, arguments) }; var _emscripten_bind_RenderResult_set_next_1 = Module._emscripten_bind_RenderResult_set_next_1 = function () { return (_emscripten_bind_RenderResult_set_next_1 = Module._emscripten_bind_RenderResult_set_next_1 = Module.asm.yb).apply(null, arguments) }; var _emscripten_bind_ASS_Track_get_n_styles_0 = Module._emscripten_bind_ASS_Track_get_n_styles_0 = function () { return (_emscripten_bind_ASS_Track_get_n_styles_0 = Module._emscripten_bind_ASS_Track_get_n_styles_0 = Module.asm.zb).apply(null, arguments) }; var _emscripten_bind_ASS_Track_set_n_styles_1 = Module._emscripten_bind_ASS_Track_set_n_styles_1 = function () { return (_emscripten_bind_ASS_Track_set_n_styles_1 = Module._emscripten_bind_ASS_Track_set_n_styles_1 = Module.asm.Ab).apply(null, arguments) }; var _emscripten_bind_ASS_Track_get_max_styles_0 = Module._emscripten_bind_ASS_Track_get_max_styles_0 = function () { return (_emscripten_bind_ASS_Track_get_max_styles_0 = Module._emscripten_bind_ASS_Track_get_max_styles_0 = Module.asm.Bb).apply(null, arguments) }; var _emscripten_bind_ASS_Track_set_max_styles_1 = Module._emscripten_bind_ASS_Track_set_max_styles_1 = function () { return (_emscripten_bind_ASS_Track_set_max_styles_1 = Module._emscripten_bind_ASS_Track_set_max_styles_1 = Module.asm.Cb).apply(null, arguments) }; var _emscripten_bind_ASS_Track_get_n_events_0 = Module._emscripten_bind_ASS_Track_get_n_events_0 = function () { return (_emscripten_bind_ASS_Track_get_n_events_0 = Module._emscripten_bind_ASS_Track_get_n_events_0 = Module.asm.Db).apply(null, arguments) }; var _emscripten_bind_ASS_Track_set_n_events_1 = Module._emscripten_bind_ASS_Track_set_n_events_1 = function () { return (_emscripten_bind_ASS_Track_set_n_events_1 = Module._emscripten_bind_ASS_Track_set_n_events_1 = Module.asm.Eb).apply(null, arguments) }; var _emscripten_bind_ASS_Track_get_max_events_0 = Module._emscripten_bind_ASS_Track_get_max_events_0 = function () { return (_emscripten_bind_ASS_Track_get_max_events_0 = Module._emscripten_bind_ASS_Track_get_max_events_0 = Module.asm.Fb).apply(null, arguments) }; var _emscripten_bind_ASS_Track_set_max_events_1 = Module._emscripten_bind_ASS_Track_set_max_events_1 = function () { return (_emscripten_bind_ASS_Track_set_max_events_1 = Module._emscripten_bind_ASS_Track_set_max_events_1 = Module.asm.Gb).apply(null, arguments) }; var _emscripten_bind_ASS_Track_get_styles_1 = Module._emscripten_bind_ASS_Track_get_styles_1 = function () { return (_emscripten_bind_ASS_Track_get_styles_1 = Module._emscripten_bind_ASS_Track_get_styles_1 = Module.asm.Hb).apply(null, arguments) }; var _emscripten_bind_ASS_Track_set_styles_2 = Module._emscripten_bind_ASS_Track_set_styles_2 = function () { return (_emscripten_bind_ASS_Track_set_styles_2 = Module._emscripten_bind_ASS_Track_set_styles_2 = Module.asm.Ib).apply(null, arguments) }; var _emscripten_bind_ASS_Track_get_events_1 = Module._emscripten_bind_ASS_Track_get_events_1 = function () { return (_emscripten_bind_ASS_Track_get_events_1 = Module._emscripten_bind_ASS_Track_get_events_1 = Module.asm.Jb).apply(null, arguments) }; var _emscripten_bind_ASS_Track_set_events_2 = Module._emscripten_bind_ASS_Track_set_events_2 = function () { return (_emscripten_bind_ASS_Track_set_events_2 = Module._emscripten_bind_ASS_Track_set_events_2 = Module.asm.Kb).apply(null, arguments) }; var _emscripten_bind_ASS_Track_get_style_format_0 = Module._emscripten_bind_ASS_Track_get_style_format_0 = function () { return (_emscripten_bind_ASS_Track_get_style_format_0 = Module._emscripten_bind_ASS_Track_get_style_format_0 = Module.asm.Lb).apply(null, arguments) }; var _emscripten_bind_ASS_Track_set_style_format_1 = Module._emscripten_bind_ASS_Track_set_style_format_1 = function () { return (_emscripten_bind_ASS_Track_set_style_format_1 = Module._emscripten_bind_ASS_Track_set_style_format_1 = Module.asm.Mb).apply(null, arguments) }; var _emscripten_bind_ASS_Track_get_event_format_0 = Module._emscripten_bind_ASS_Track_get_event_format_0 = function () { return (_emscripten_bind_ASS_Track_get_event_format_0 = Module._emscripten_bind_ASS_Track_get_event_format_0 = Module.asm.Nb).apply(null, arguments) }; var _emscripten_bind_ASS_Track_set_event_format_1 = Module._emscripten_bind_ASS_Track_set_event_format_1 = function () { return (_emscripten_bind_ASS_Track_set_event_format_1 = Module._emscripten_bind_ASS_Track_set_event_format_1 = Module.asm.Ob).apply(null, arguments) }; var _emscripten_bind_ASS_Track_get_PlayResX_0 = Module._emscripten_bind_ASS_Track_get_PlayResX_0 = function () { return (_emscripten_bind_ASS_Track_get_PlayResX_0 = Module._emscripten_bind_ASS_Track_get_PlayResX_0 = Module.asm.Pb).apply(null, arguments) }; var _emscripten_bind_ASS_Track_set_PlayResX_1 = Module._emscripten_bind_ASS_Track_set_PlayResX_1 = function () { return (_emscripten_bind_ASS_Track_set_PlayResX_1 = Module._emscripten_bind_ASS_Track_set_PlayResX_1 = Module.asm.Qb).apply(null, arguments) }; var _emscripten_bind_ASS_Track_get_PlayResY_0 = Module._emscripten_bind_ASS_Track_get_PlayResY_0 = function () { return (_emscripten_bind_ASS_Track_get_PlayResY_0 = Module._emscripten_bind_ASS_Track_get_PlayResY_0 = Module.asm.Rb).apply(null, arguments) }; var _emscripten_bind_ASS_Track_set_PlayResY_1 = Module._emscripten_bind_ASS_Track_set_PlayResY_1 = function () { return (_emscripten_bind_ASS_Track_set_PlayResY_1 = Module._emscripten_bind_ASS_Track_set_PlayResY_1 = Module.asm.Sb).apply(null, arguments) }; var _emscripten_bind_ASS_Track_get_Timer_0 = Module._emscripten_bind_ASS_Track_get_Timer_0 = function () { return (_emscripten_bind_ASS_Track_get_Timer_0 = Module._emscripten_bind_ASS_Track_get_Timer_0 = Module.asm.Tb).apply(null, arguments) }; var _emscripten_bind_ASS_Track_set_Timer_1 = Module._emscripten_bind_ASS_Track_set_Timer_1 = function () { return (_emscripten_bind_ASS_Track_set_Timer_1 = Module._emscripten_bind_ASS_Track_set_Timer_1 = Module.asm.Ub).apply(null, arguments) }; var _emscripten_bind_ASS_Track_get_WrapStyle_0 = Module._emscripten_bind_ASS_Track_get_WrapStyle_0 = function () { return (_emscripten_bind_ASS_Track_get_WrapStyle_0 = Module._emscripten_bind_ASS_Track_get_WrapStyle_0 = Module.asm.Vb).apply(null, arguments) }; var _emscripten_bind_ASS_Track_set_WrapStyle_1 = Module._emscripten_bind_ASS_Track_set_WrapStyle_1 = function () { return (_emscripten_bind_ASS_Track_set_WrapStyle_1 = Module._emscripten_bind_ASS_Track_set_WrapStyle_1 = Module.asm.Wb).apply(null, arguments) }; var _emscripten_bind_ASS_Track_get_ScaledBorderAndShadow_0 = Module._emscripten_bind_ASS_Track_get_ScaledBorderAndShadow_0 = function () { return (_emscripten_bind_ASS_Track_get_ScaledBorderAndShadow_0 = Module._emscripten_bind_ASS_Track_get_ScaledBorderAndShadow_0 = Module.asm.Xb).apply(null, arguments) }; var _emscripten_bind_ASS_Track_set_ScaledBorderAndShadow_1 = Module._emscripten_bind_ASS_Track_set_ScaledBorderAndShadow_1 = function () { return (_emscripten_bind_ASS_Track_set_ScaledBorderAndShadow_1 = Module._emscripten_bind_ASS_Track_set_ScaledBorderAndShadow_1 = Module.asm.Yb).apply(null, arguments) }; var _emscripten_bind_ASS_Track_get_Kerning_0 = Module._emscripten_bind_ASS_Track_get_Kerning_0 = function () { return (_emscripten_bind_ASS_Track_get_Kerning_0 = Module._emscripten_bind_ASS_Track_get_Kerning_0 = Module.asm.Zb).apply(null, arguments) }; var _emscripten_bind_ASS_Track_set_Kerning_1 = Module._emscripten_bind_ASS_Track_set_Kerning_1 = function () { return (_emscripten_bind_ASS_Track_set_Kerning_1 = Module._emscripten_bind_ASS_Track_set_Kerning_1 = Module.asm._b).apply(null, arguments) }; var _emscripten_bind_ASS_Track_get_Language_0 = Module._emscripten_bind_ASS_Track_get_Language_0 = function () { return (_emscripten_bind_ASS_Track_get_Language_0 = Module._emscripten_bind_ASS_Track_get_Language_0 = Module.asm.$b).apply(null, arguments) }; var _emscripten_bind_ASS_Track_set_Language_1 = Module._emscripten_bind_ASS_Track_set_Language_1 = function () { return (_emscripten_bind_ASS_Track_set_Language_1 = Module._emscripten_bind_ASS_Track_set_Language_1 = Module.asm.ac).apply(null, arguments) }; var _emscripten_bind_ASS_Track_get_default_style_0 = Module._emscripten_bind_ASS_Track_get_default_style_0 = function () { return (_emscripten_bind_ASS_Track_get_default_style_0 = Module._emscripten_bind_ASS_Track_get_default_style_0 = Module.asm.bc).apply(null, arguments) }; var _emscripten_bind_ASS_Track_set_default_style_1 = Module._emscripten_bind_ASS_Track_set_default_style_1 = function () { return (_emscripten_bind_ASS_Track_set_default_style_1 = Module._emscripten_bind_ASS_Track_set_default_style_1 = Module.asm.cc).apply(null, arguments) }; var _emscripten_bind_ASS_Track_get_name_0 = Module._emscripten_bind_ASS_Track_get_name_0 = function () { return (_emscripten_bind_ASS_Track_get_name_0 = Module._emscripten_bind_ASS_Track_get_name_0 = Module.asm.dc).apply(null, arguments) }; var _emscripten_bind_ASS_Track_set_name_1 = Module._emscripten_bind_ASS_Track_set_name_1 = function () { return (_emscripten_bind_ASS_Track_set_name_1 = Module._emscripten_bind_ASS_Track_set_name_1 = Module.asm.ec).apply(null, arguments) }; var _emscripten_bind_JASSUB_JASSUB_0 = Module._emscripten_bind_JASSUB_JASSUB_0 = function () { return (_emscripten_bind_JASSUB_JASSUB_0 = Module._emscripten_bind_JASSUB_JASSUB_0 = Module.asm.fc).apply(null, arguments) }; var _emscripten_bind_JASSUB_setLogLevel_1 = Module._emscripten_bind_JASSUB_setLogLevel_1 = function () { return (_emscripten_bind_JASSUB_setLogLevel_1 = Module._emscripten_bind_JASSUB_setLogLevel_1 = Module.asm.gc).apply(null, arguments) }; var _emscripten_bind_JASSUB_setDropAnimations_1 = Module._emscripten_bind_JASSUB_setDropAnimations_1 = function () { return (_emscripten_bind_JASSUB_setDropAnimations_1 = Module._emscripten_bind_JASSUB_setDropAnimations_1 = Module.asm.hc).apply(null, arguments) }; var _emscripten_bind_JASSUB_initLibrary_3 = Module._emscripten_bind_JASSUB_initLibrary_3 = function () { return (_emscripten_bind_JASSUB_initLibrary_3 = Module._emscripten_bind_JASSUB_initLibrary_3 = Module.asm.ic).apply(null, arguments) }; var _free = Module._free = function () { return (_free = Module._free = Module.asm.jc).apply(null, arguments) }; var _emscripten_bind_JASSUB_createTrackMem_2 = Module._emscripten_bind_JASSUB_createTrackMem_2 = function () { return (_emscripten_bind_JASSUB_createTrackMem_2 = Module._emscripten_bind_JASSUB_createTrackMem_2 = Module.asm.kc).apply(null, arguments) }; var _emscripten_bind_JASSUB_removeTrack_0 = Module._emscripten_bind_JASSUB_removeTrack_0 = function () { return (_emscripten_bind_JASSUB_removeTrack_0 = Module._emscripten_bind_JASSUB_removeTrack_0 = Module.asm.lc).apply(null, arguments) }; var _emscripten_bind_JASSUB_resizeCanvas_2 = Module._emscripten_bind_JASSUB_resizeCanvas_2 = function () { return (_emscripten_bind_JASSUB_resizeCanvas_2 = Module._emscripten_bind_JASSUB_resizeCanvas_2 = Module.asm.mc).apply(null, arguments) }; var _emscripten_bind_JASSUB_renderImage_2 = Module._emscripten_bind_JASSUB_renderImage_2 = function () { return (_emscripten_bind_JASSUB_renderImage_2 = Module._emscripten_bind_JASSUB_renderImage_2 = Module.asm.nc).apply(null, arguments) }; var _emscripten_bind_JASSUB_quitLibrary_0 = Module._emscripten_bind_JASSUB_quitLibrary_0 = function () { return (_emscripten_bind_JASSUB_quitLibrary_0 = Module._emscripten_bind_JASSUB_quitLibrary_0 = Module.asm.oc).apply(null, arguments) }; var _emscripten_bind_JASSUB_reloadLibrary_0 = Module._emscripten_bind_JASSUB_reloadLibrary_0 = function () { return (_emscripten_bind_JASSUB_reloadLibrary_0 = Module._emscripten_bind_JASSUB_reloadLibrary_0 = Module.asm.pc).apply(null, arguments) }; var _emscripten_bind_JASSUB_addFont_3 = Module._emscripten_bind_JASSUB_addFont_3 = function () { return (_emscripten_bind_JASSUB_addFont_3 = Module._emscripten_bind_JASSUB_addFont_3 = Module.asm.qc).apply(null, arguments) }; var _emscripten_bind_JASSUB_reloadFonts_0 = Module._emscripten_bind_JASSUB_reloadFonts_0 = function () { return (_emscripten_bind_JASSUB_reloadFonts_0 = Module._emscripten_bind_JASSUB_reloadFonts_0 = Module.asm.rc).apply(null, arguments) }; var _emscripten_bind_JASSUB_setMargin_4 = Module._emscripten_bind_JASSUB_setMargin_4 = function () { return (_emscripten_bind_JASSUB_setMargin_4 = Module._emscripten_bind_JASSUB_setMargin_4 = Module.asm.sc).apply(null, arguments) }; var _emscripten_bind_JASSUB_getEventCount_0 = Module._emscripten_bind_JASSUB_getEventCount_0 = function () { return (_emscripten_bind_JASSUB_getEventCount_0 = Module._emscripten_bind_JASSUB_getEventCount_0 = Module.asm.tc).apply(null, arguments) }; var _emscripten_bind_JASSUB_allocEvent_0 = Module._emscripten_bind_JASSUB_allocEvent_0 = function () { return (_emscripten_bind_JASSUB_allocEvent_0 = Module._emscripten_bind_JASSUB_allocEvent_0 = Module.asm.uc).apply(null, arguments) }; var _emscripten_bind_JASSUB_allocStyle_0 = Module._emscripten_bind_JASSUB_allocStyle_0 = function () { return (_emscripten_bind_JASSUB_allocStyle_0 = Module._emscripten_bind_JASSUB_allocStyle_0 = Module.asm.vc).apply(null, arguments) }; var _emscripten_bind_JASSUB_removeEvent_1 = Module._emscripten_bind_JASSUB_removeEvent_1 = function () { return (_emscripten_bind_JASSUB_removeEvent_1 = Module._emscripten_bind_JASSUB_removeEvent_1 = Module.asm.wc).apply(null, arguments) }; var _emscripten_bind_JASSUB_getStyleCount_0 = Module._emscripten_bind_JASSUB_getStyleCount_0 = function () { return (_emscripten_bind_JASSUB_getStyleCount_0 = Module._emscripten_bind_JASSUB_getStyleCount_0 = Module.asm.xc).apply(null, arguments) }; var _emscripten_bind_JASSUB_getStyleByName_1 = Module._emscripten_bind_JASSUB_getStyleByName_1 = function () { return (_emscripten_bind_JASSUB_getStyleByName_1 = Module._emscripten_bind_JASSUB_getStyleByName_1 = Module.asm.yc).apply(null, arguments) }; var _emscripten_bind_JASSUB_removeStyle_1 = Module._emscripten_bind_JASSUB_removeStyle_1 = function () { return (_emscripten_bind_JASSUB_removeStyle_1 = Module._emscripten_bind_JASSUB_removeStyle_1 = Module.asm.zc).apply(null, arguments) }; var _emscripten_bind_JASSUB_removeAllEvents_0 = Module._emscripten_bind_JASSUB_removeAllEvents_0 = function () { return (_emscripten_bind_JASSUB_removeAllEvents_0 = Module._emscripten_bind_JASSUB_removeAllEvents_0 = Module.asm.Ac).apply(null, arguments) }; var _emscripten_bind_JASSUB_setMemoryLimits_2 = Module._emscripten_bind_JASSUB_setMemoryLimits_2 = function () { return (_emscripten_bind_JASSUB_setMemoryLimits_2 = Module._emscripten_bind_JASSUB_setMemoryLimits_2 = Module.asm.Bc).apply(null, arguments) }; var _emscripten_bind_JASSUB_renderBlend_2 = Module._emscripten_bind_JASSUB_renderBlend_2 = function () { return (_emscripten_bind_JASSUB_renderBlend_2 = Module._emscripten_bind_JASSUB_renderBlend_2 = Module.asm.Cc).apply(null, arguments) }; var _emscripten_bind_JASSUB_get_track_0 = Module._emscripten_bind_JASSUB_get_track_0 = function () { return (_emscripten_bind_JASSUB_get_track_0 = Module._emscripten_bind_JASSUB_get_track_0 = Module.asm.Dc).apply(null, arguments) }; var _emscripten_bind_JASSUB_set_track_1 = Module._emscripten_bind_JASSUB_set_track_1 = function () { return (_emscripten_bind_JASSUB_set_track_1 = Module._emscripten_bind_JASSUB_set_track_1 = Module.asm.Ec).apply(null, arguments) }; var _emscripten_bind_JASSUB___destroy___0 = Module._emscripten_bind_JASSUB___destroy___0 = function () { return (_emscripten_bind_JASSUB___destroy___0 = Module._emscripten_bind_JASSUB___destroy___0 = Module.asm.Fc).apply(null, arguments) }; var ___errno_location = Module.___errno_location = function () { return (___errno_location = Module.___errno_location = Module.asm.Hc).apply(null, arguments) }; var _malloc = Module._malloc = function () { return (_malloc = Module._malloc = Module.asm.Ic).apply(null, arguments) }; var stackSave = Module.stackSave = function () { return (stackSave = Module.stackSave = Module.asm.Jc).apply(null, arguments) }; var stackRestore = Module.stackRestore = function () { return (stackRestore = Module.stackRestore = Module.asm.Kc).apply(null, arguments) }; var stackAlloc = Module.stackAlloc = function () { return (stackAlloc = Module.stackAlloc = Module.asm.Lc).apply(null, arguments) }; var _setThrew = Module._setThrew = function () { return (_setThrew = Module._setThrew = Module.asm.Mc).apply(null, arguments) }; var _memalign = Module._memalign = function () { return (_memalign = Module._memalign = Module.asm.Nc).apply(null, arguments) }; function invoke_iii (index, a1, a2) { const sp = stackSave(); try { return getWasmTableEntry(index)(a1, a2) } catch (e) { stackRestore(sp); if (e !== e + 0 && e !== 'longjmp') throw e; _setThrew(1, 0) } } function invoke_iiiii (index, a1, a2, a3, a4) { const sp = stackSave(); try { return getWasmTableEntry(index)(a1, a2, a3, a4) } catch (e) { stackRestore(sp); if (e !== e + 0 && e !== 'longjmp') throw e; _setThrew(1, 0) } } function invoke_iiii (index, a1, a2, a3) { const sp = stackSave(); try { return getWasmTableEntry(index)(a1, a2, a3) } catch (e) { stackRestore(sp); if (e !== e + 0 && e !== 'longjmp') throw e; _setThrew(1, 0) } }Module.addRunDependency = addRunDependency; Module.removeRunDependency = removeRunDependency; Module.FS_createPath = FS.createPath; Module.FS_createDataFile = FS.createDataFile; Module.FS_createPreloadedFile = FS.createPreloadedFile; Module.FS_createLazyFile = FS.createLazyFile; Module.FS_createDevice = FS.createDevice; Module.FS_unlink = FS.unlink; let calledRun; function ExitStatus (status) { this.name = 'ExitStatus'; this.message = 'Program terminated with exit(' + status + ')'; this.status = status } let calledMain = false; dependenciesFulfilled = function runCaller () { if (!calledRun)run(); if (!calledRun)dependenciesFulfilled = runCaller }; function callMain (args) { const entryFunction = Module._main; args = args || []; const argc = args.length + 1; const argv = stackAlloc((argc + 1) * 4); HEAP32[argv >> 2] = allocateUTF8OnStack(thisProgram); for (let i = 1; i < argc; i++) { HEAP32[(argv >> 2) + i] = allocateUTF8OnStack(args[i - 1]) }HEAP32[(argv >> 2) + argc] = 0; try { const ret = entryFunction(argc, argv); exit(ret, true); return ret } catch (e) { return handleException(e) } finally { calledMain = true } } function run (args) { args = args || arguments_; if (runDependencies > 0) { return }preRun(); if (runDependencies > 0) { return } function doRun () { if (calledRun) return; calledRun = true; Module.calledRun = true; if (ABORT) return; initRuntime(); preMain(); if (Module.onRuntimeInitialized)Module.onRuntimeInitialized(); if (shouldRunNow)callMain(args); postRun() } { doRun() } }Module.run = run; function exit (status, implicit) { EXITSTATUS = status; if (keepRuntimeAlive()) {} else { exitRuntime() }procExit(status) } function procExit (code) { EXITSTATUS = code; if (!keepRuntimeAlive()) { ABORT = true }quit_(code, new ExitStatus(code)) } var shouldRunNow = true; run(); function WrapperObject () {}WrapperObject.prototype = Object.create(WrapperObject.prototype); WrapperObject.prototype.constructor = WrapperObject; WrapperObject.prototype.__class__ = WrapperObject; WrapperObject.__cache__ = {}; Module.WrapperObject = WrapperObject; function getCache (__class__) { return (__class__ || WrapperObject).__cache__ }Module.getCache = getCache; function wrapPointer (ptr, __class__) { const cache = getCache(__class__); let ret = cache[ptr]; if (ret) return ret; ret = Object.create((__class__ || WrapperObject).prototype); ret.ptr = ptr; return cache[ptr] = ret }Module.wrapPointer = wrapPointer; function castObject (obj, __class__) { return wrapPointer(obj.ptr, __class__) }Module.castObject = castObject; Module.NULL = wrapPointer(0); function destroy (obj) { if (!obj.__destroy__) throw 'Error: Cannot destroy object. (Did you create it yourself?)'; obj.__destroy__(); delete getCache(obj.__class__)[obj.ptr] }Module.destroy = destroy; function compare (obj1, obj2) { return obj1.ptr === obj2.ptr }Module.compare = compare; function getPointer (obj) { return obj.ptr }Module.getPointer = getPointer; function getClass (obj) { return obj.__class__ }Module.getClass = getClass; var ensureCache = { buffer: 0, size: 0, pos: 0, temps: [], owned: [], needed: 0, prepare: function () { if (ensureCache.needed) { for (let i = 0; i < ensureCache.temps.length; i++) { Module._free(ensureCache.temps[i]) }ensureCache.temps.length = 0; Module._free(ensureCache.buffer); ensureCache.buffer = 0; ensureCache.size += ensureCache.needed; ensureCache.needed = 0 } if (!ensureCache.buffer) { ensureCache.size += 128; ensureCache.buffer = Module._malloc(ensureCache.size); assert(ensureCache.buffer) }ensureCache.pos = 0 }, alloc: function (array, view, owner) { assert(ensureCache.buffer); const bytes = view.BYTES_PER_ELEMENT; let len = array.length * bytes; len = len + 7 & -8; let ret; if (owner) { assert(len > 0); ensureCache.needed += len; ret = Module._malloc(len); ensureCache.owned.push(ret) } else { if (ensureCache.pos + len >= ensureCache.size) { assert(len > 0); ensureCache.needed += len; ret = Module._malloc(len); ensureCache.temps.push(ret) } else { ret = ensureCache.buffer + ensureCache.pos; ensureCache.pos += len } } return ret }, copy: function (array, view, offset) { offset >>>= 0; const bytes = view.BYTES_PER_ELEMENT; switch (bytes) { case 2:offset >>>= 1; break; case 4:offset >>>= 2; break; case 8:offset >>>= 3; break } for (let i = 0; i < array.length; i++) { view[offset + i] = array[i] } }, clear: function (clearOwned) { for (var i = 0; i < ensureCache.temps.length; i++) { Module._free(ensureCache.temps[i]) } if (clearOwned) { for (var i = 0; i < ensureCache.owned.length; i++) { Module._free(ensureCache.owned[i]) } }ensureCache.temps.length = 0; Module._free(ensureCache.buffer); ensureCache.buffer = 0; ensureCache.size = 0; ensureCache.needed = 0 } }; function ensureString (value, owner) { if (typeof value === 'string') { const intArray = intArrayFromString(value); const offset = ensureCache.alloc(intArray, HEAP8, owner); ensureCache.copy(intArray, HEAP8, offset); return offset } return value } function VoidPtr () { throw 'cannot construct a VoidPtr, no constructor in IDL' }VoidPtr.prototype = Object.create(WrapperObject.prototype); VoidPtr.prototype.constructor = VoidPtr; VoidPtr.prototype.__class__ = VoidPtr; VoidPtr.__cache__ = {}; Module.VoidPtr = VoidPtr; VoidPtr.prototype.__destroy__ = VoidPtr.prototype.__destroy__ = function () { const self = this.ptr; _emscripten_bind_VoidPtr___destroy___0(self) }; function ASS_Style () { throw 'cannot construct a ASS_Style, no constructor in IDL' }ASS_Style.prototype = Object.create(WrapperObject.prototype); ASS_Style.prototype.constructor = ASS_Style; ASS_Style.prototype.__class__ = ASS_Style; ASS_Style.__cache__ = {}; Module.ASS_Style = ASS_Style; ASS_Style.prototype.get_Name = ASS_Style.prototype.get_Name = function () { const self = this.ptr; return UTF8ToString(_emscripten_bind_ASS_Style_get_Name_0(self)) }; ASS_Style.prototype.set_Name = ASS_Style.prototype.set_Name = function (arg0) { const self = this.ptr; ensureCache.prepare(); if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; else arg0 = ensureString(arg0, true); _emscripten_bind_ASS_Style_set_Name_1(self, arg0) }; Object.defineProperty(ASS_Style.prototype, 'Name', { get: ASS_Style.prototype.get_Name, set: ASS_Style.prototype.set_Name }); ASS_Style.prototype.get_FontName = ASS_Style.prototype.get_FontName = function () { const self = this.ptr; return UTF8ToString(_emscripten_bind_ASS_Style_get_FontName_0(self)) }; ASS_Style.prototype.set_FontName = ASS_Style.prototype.set_FontName = function (arg0) { const self = this.ptr; ensureCache.prepare(); if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; else arg0 = ensureString(arg0, true); _emscripten_bind_ASS_Style_set_FontName_1(self, arg0) }; Object.defineProperty(ASS_Style.prototype, 'FontName', { get: ASS_Style.prototype.get_FontName, set: ASS_Style.prototype.set_FontName }); ASS_Style.prototype.get_FontSize = ASS_Style.prototype.get_FontSize = function () { const self = this.ptr; return _emscripten_bind_ASS_Style_get_FontSize_0(self) }; ASS_Style.prototype.set_FontSize = ASS_Style.prototype.set_FontSize = function (arg0) { const self = this.ptr; if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; _emscripten_bind_ASS_Style_set_FontSize_1(self, arg0) }; Object.defineProperty(ASS_Style.prototype, 'FontSize', { get: ASS_Style.prototype.get_FontSize, set: ASS_Style.prototype.set_FontSize }); ASS_Style.prototype.get_PrimaryColour = ASS_Style.prototype.get_PrimaryColour = function () { const self = this.ptr; return _emscripten_bind_ASS_Style_get_PrimaryColour_0(self) }; ASS_Style.prototype.set_PrimaryColour = ASS_Style.prototype.set_PrimaryColour = function (arg0) { const self = this.ptr; if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; _emscripten_bind_ASS_Style_set_PrimaryColour_1(self, arg0) }; Object.defineProperty(ASS_Style.prototype, 'PrimaryColour', { get: ASS_Style.prototype.get_PrimaryColour, set: ASS_Style.prototype.set_PrimaryColour }); ASS_Style.prototype.get_SecondaryColour = ASS_Style.prototype.get_SecondaryColour = function () { const self = this.ptr; return _emscripten_bind_ASS_Style_get_SecondaryColour_0(self) }; ASS_Style.prototype.set_SecondaryColour = ASS_Style.prototype.set_SecondaryColour = function (arg0) { const self = this.ptr; if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; _emscripten_bind_ASS_Style_set_SecondaryColour_1(self, arg0) }; Object.defineProperty(ASS_Style.prototype, 'SecondaryColour', { get: ASS_Style.prototype.get_SecondaryColour, set: ASS_Style.prototype.set_SecondaryColour }); ASS_Style.prototype.get_OutlineColour = ASS_Style.prototype.get_OutlineColour = function () { const self = this.ptr; return _emscripten_bind_ASS_Style_get_OutlineColour_0(self) }; ASS_Style.prototype.set_OutlineColour = ASS_Style.prototype.set_OutlineColour = function (arg0) { const self = this.ptr; if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; _emscripten_bind_ASS_Style_set_OutlineColour_1(self, arg0) }; Object.defineProperty(ASS_Style.prototype, 'OutlineColour', { get: ASS_Style.prototype.get_OutlineColour, set: ASS_Style.prototype.set_OutlineColour }); ASS_Style.prototype.get_BackColour = ASS_Style.prototype.get_BackColour = function () { const self = this.ptr; return _emscripten_bind_ASS_Style_get_BackColour_0(self) }; ASS_Style.prototype.set_BackColour = ASS_Style.prototype.set_BackColour = function (arg0) { const self = this.ptr; if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; _emscripten_bind_ASS_Style_set_BackColour_1(self, arg0) }; Object.defineProperty(ASS_Style.prototype, 'BackColour', { get: ASS_Style.prototype.get_BackColour, set: ASS_Style.prototype.set_BackColour }); ASS_Style.prototype.get_Bold = ASS_Style.prototype.get_Bold = function () { const self = this.ptr; return _emscripten_bind_ASS_Style_get_Bold_0(self) }; ASS_Style.prototype.set_Bold = ASS_Style.prototype.set_Bold = function (arg0) { const self = this.ptr; if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; _emscripten_bind_ASS_Style_set_Bold_1(self, arg0) }; Object.defineProperty(ASS_Style.prototype, 'Bold', { get: ASS_Style.prototype.get_Bold, set: ASS_Style.prototype.set_Bold }); ASS_Style.prototype.get_Italic = ASS_Style.prototype.get_Italic = function () { const self = this.ptr; return _emscripten_bind_ASS_Style_get_Italic_0(self) }; ASS_Style.prototype.set_Italic = ASS_Style.prototype.set_Italic = function (arg0) { const self = this.ptr; if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; _emscripten_bind_ASS_Style_set_Italic_1(self, arg0) }; Object.defineProperty(ASS_Style.prototype, 'Italic', { get: ASS_Style.prototype.get_Italic, set: ASS_Style.prototype.set_Italic }); ASS_Style.prototype.get_Underline = ASS_Style.prototype.get_Underline = function () { const self = this.ptr; return _emscripten_bind_ASS_Style_get_Underline_0(self) }; ASS_Style.prototype.set_Underline = ASS_Style.prototype.set_Underline = function (arg0) { const self = this.ptr; if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; _emscripten_bind_ASS_Style_set_Underline_1(self, arg0) }; Object.defineProperty(ASS_Style.prototype, 'Underline', { get: ASS_Style.prototype.get_Underline, set: ASS_Style.prototype.set_Underline }); ASS_Style.prototype.get_StrikeOut = ASS_Style.prototype.get_StrikeOut = function () { const self = this.ptr; return _emscripten_bind_ASS_Style_get_StrikeOut_0(self) }; ASS_Style.prototype.set_StrikeOut = ASS_Style.prototype.set_StrikeOut = function (arg0) { const self = this.ptr; if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; _emscripten_bind_ASS_Style_set_StrikeOut_1(self, arg0) }; Object.defineProperty(ASS_Style.prototype, 'StrikeOut', { get: ASS_Style.prototype.get_StrikeOut, set: ASS_Style.prototype.set_StrikeOut }); ASS_Style.prototype.get_ScaleX = ASS_Style.prototype.get_ScaleX = function () { const self = this.ptr; return _emscripten_bind_ASS_Style_get_ScaleX_0(self) }; ASS_Style.prototype.set_ScaleX = ASS_Style.prototype.set_ScaleX = function (arg0) { const self = this.ptr; if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; _emscripten_bind_ASS_Style_set_ScaleX_1(self, arg0) }; Object.defineProperty(ASS_Style.prototype, 'ScaleX', { get: ASS_Style.prototype.get_ScaleX, set: ASS_Style.prototype.set_ScaleX }); ASS_Style.prototype.get_ScaleY = ASS_Style.prototype.get_ScaleY = function () { const self = this.ptr; return _emscripten_bind_ASS_Style_get_ScaleY_0(self) }; ASS_Style.prototype.set_ScaleY = ASS_Style.prototype.set_ScaleY = function (arg0) { const self = this.ptr; if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; _emscripten_bind_ASS_Style_set_ScaleY_1(self, arg0) }; Object.defineProperty(ASS_Style.prototype, 'ScaleY', { get: ASS_Style.prototype.get_ScaleY, set: ASS_Style.prototype.set_ScaleY }); ASS_Style.prototype.get_Spacing = ASS_Style.prototype.get_Spacing = function () { const self = this.ptr; return _emscripten_bind_ASS_Style_get_Spacing_0(self) }; ASS_Style.prototype.set_Spacing = ASS_Style.prototype.set_Spacing = function (arg0) { const self = this.ptr; if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; _emscripten_bind_ASS_Style_set_Spacing_1(self, arg0) }; Object.defineProperty(ASS_Style.prototype, 'Spacing', { get: ASS_Style.prototype.get_Spacing, set: ASS_Style.prototype.set_Spacing }); ASS_Style.prototype.get_Angle = ASS_Style.prototype.get_Angle = function () { const self = this.ptr; return _emscripten_bind_ASS_Style_get_Angle_0(self) }; ASS_Style.prototype.set_Angle = ASS_Style.prototype.set_Angle = function (arg0) { const self = this.ptr; if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; _emscripten_bind_ASS_Style_set_Angle_1(self, arg0) }; Object.defineProperty(ASS_Style.prototype, 'Angle', { get: ASS_Style.prototype.get_Angle, set: ASS_Style.prototype.set_Angle }); ASS_Style.prototype.get_BorderStyle = ASS_Style.prototype.get_BorderStyle = function () { const self = this.ptr; return _emscripten_bind_ASS_Style_get_BorderStyle_0(self) }; ASS_Style.prototype.set_BorderStyle = ASS_Style.prototype.set_BorderStyle = function (arg0) { const self = this.ptr; if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; _emscripten_bind_ASS_Style_set_BorderStyle_1(self, arg0) }; Object.defineProperty(ASS_Style.prototype, 'BorderStyle', { get: ASS_Style.prototype.get_BorderStyle, set: ASS_Style.prototype.set_BorderStyle }); ASS_Style.prototype.get_Outline = ASS_Style.prototype.get_Outline = function () { const self = this.ptr; return _emscripten_bind_ASS_Style_get_Outline_0(self) }; ASS_Style.prototype.set_Outline = ASS_Style.prototype.set_Outline = function (arg0) { const self = this.ptr; if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; _emscripten_bind_ASS_Style_set_Outline_1(self, arg0) }; Object.defineProperty(ASS_Style.prototype, 'Outline', { get: ASS_Style.prototype.get_Outline, set: ASS_Style.prototype.set_Outline }); ASS_Style.prototype.get_Shadow = ASS_Style.prototype.get_Shadow = function () { const self = this.ptr; return _emscripten_bind_ASS_Style_get_Shadow_0(self) }; ASS_Style.prototype.set_Shadow = ASS_Style.prototype.set_Shadow = function (arg0) { const self = this.ptr; if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; _emscripten_bind_ASS_Style_set_Shadow_1(self, arg0) }; Object.defineProperty(ASS_Style.prototype, 'Shadow', { get: ASS_Style.prototype.get_Shadow, set: ASS_Style.prototype.set_Shadow }); ASS_Style.prototype.get_Alignment = ASS_Style.prototype.get_Alignment = function () { const self = this.ptr; return _emscripten_bind_ASS_Style_get_Alignment_0(self) }; ASS_Style.prototype.set_Alignment = ASS_Style.prototype.set_Alignment = function (arg0) { const self = this.ptr; if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; _emscripten_bind_ASS_Style_set_Alignment_1(self, arg0) }; Object.defineProperty(ASS_Style.prototype, 'Alignment', { get: ASS_Style.prototype.get_Alignment, set: ASS_Style.prototype.set_Alignment }); ASS_Style.prototype.get_MarginL = ASS_Style.prototype.get_MarginL = function () { const self = this.ptr; return _emscripten_bind_ASS_Style_get_MarginL_0(self) }; ASS_Style.prototype.set_MarginL = ASS_Style.prototype.set_MarginL = function (arg0) { const self = this.ptr; if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; _emscripten_bind_ASS_Style_set_MarginL_1(self, arg0) }; Object.defineProperty(ASS_Style.prototype, 'MarginL', { get: ASS_Style.prototype.get_MarginL, set: ASS_Style.prototype.set_MarginL }); ASS_Style.prototype.get_MarginR = ASS_Style.prototype.get_MarginR = function () { const self = this.ptr; return _emscripten_bind_ASS_Style_get_MarginR_0(self) }; ASS_Style.prototype.set_MarginR = ASS_Style.prototype.set_MarginR = function (arg0) { const self = this.ptr; if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; _emscripten_bind_ASS_Style_set_MarginR_1(self, arg0) }; Object.defineProperty(ASS_Style.prototype, 'MarginR', { get: ASS_Style.prototype.get_MarginR, set: ASS_Style.prototype.set_MarginR }); ASS_Style.prototype.get_MarginV = ASS_Style.prototype.get_MarginV = function () { const self = this.ptr; return _emscripten_bind_ASS_Style_get_MarginV_0(self) }; ASS_Style.prototype.set_MarginV = ASS_Style.prototype.set_MarginV = function (arg0) { const self = this.ptr; if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; _emscripten_bind_ASS_Style_set_MarginV_1(self, arg0) }; Object.defineProperty(ASS_Style.prototype, 'MarginV', { get: ASS_Style.prototype.get_MarginV, set: ASS_Style.prototype.set_MarginV }); ASS_Style.prototype.get_Encoding = ASS_Style.prototype.get_Encoding = function () { const self = this.ptr; return _emscripten_bind_ASS_Style_get_Encoding_0(self) }; ASS_Style.prototype.set_Encoding = ASS_Style.prototype.set_Encoding = function (arg0) { const self = this.ptr; if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; _emscripten_bind_ASS_Style_set_Encoding_1(self, arg0) }; Object.defineProperty(ASS_Style.prototype, 'Encoding', { get: ASS_Style.prototype.get_Encoding, set: ASS_Style.prototype.set_Encoding }); ASS_Style.prototype.get_treat_fontname_as_pattern = ASS_Style.prototype.get_treat_fontname_as_pattern = function () { const self = this.ptr; return _emscripten_bind_ASS_Style_get_treat_fontname_as_pattern_0(self) }; ASS_Style.prototype.set_treat_fontname_as_pattern = ASS_Style.prototype.set_treat_fontname_as_pattern = function (arg0) { const self = this.ptr; if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; _emscripten_bind_ASS_Style_set_treat_fontname_as_pattern_1(self, arg0) }; Object.defineProperty(ASS_Style.prototype, 'treat_fontname_as_pattern', { get: ASS_Style.prototype.get_treat_fontname_as_pattern, set: ASS_Style.prototype.set_treat_fontname_as_pattern }); ASS_Style.prototype.get_Blur = ASS_Style.prototype.get_Blur = function () { const self = this.ptr; return _emscripten_bind_ASS_Style_get_Blur_0(self) }; ASS_Style.prototype.set_Blur = ASS_Style.prototype.set_Blur = function (arg0) { const self = this.ptr; if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; _emscripten_bind_ASS_Style_set_Blur_1(self, arg0) }; Object.defineProperty(ASS_Style.prototype, 'Blur', { get: ASS_Style.prototype.get_Blur, set: ASS_Style.prototype.set_Blur }); ASS_Style.prototype.get_Justify = ASS_Style.prototype.get_Justify = function () { const self = this.ptr; return _emscripten_bind_ASS_Style_get_Justify_0(self) }; ASS_Style.prototype.set_Justify = ASS_Style.prototype.set_Justify = function (arg0) { const self = this.ptr; if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; _emscripten_bind_ASS_Style_set_Justify_1(self, arg0) }; Object.defineProperty(ASS_Style.prototype, 'Justify', { get: ASS_Style.prototype.get_Justify, set: ASS_Style.prototype.set_Justify }); function ASS_Event () { throw 'cannot construct a ASS_Event, no constructor in IDL' }ASS_Event.prototype = Object.create(WrapperObject.prototype); ASS_Event.prototype.constructor = ASS_Event; ASS_Event.prototype.__class__ = ASS_Event; ASS_Event.__cache__ = {}; Module.ASS_Event = ASS_Event; ASS_Event.prototype.get_Start = ASS_Event.prototype.get_Start = function () { const self = this.ptr; return _emscripten_bind_ASS_Event_get_Start_0(self) }; ASS_Event.prototype.set_Start = ASS_Event.prototype.set_Start = function (arg0) { const self = this.ptr; if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; _emscripten_bind_ASS_Event_set_Start_1(self, arg0) }; Object.defineProperty(ASS_Event.prototype, 'Start', { get: ASS_Event.prototype.get_Start, set: ASS_Event.prototype.set_Start }); ASS_Event.prototype.get_Duration = ASS_Event.prototype.get_Duration = function () { const self = this.ptr; return _emscripten_bind_ASS_Event_get_Duration_0(self) }; ASS_Event.prototype.set_Duration = ASS_Event.prototype.set_Duration = function (arg0) { const self = this.ptr; if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; _emscripten_bind_ASS_Event_set_Duration_1(self, arg0) }; Object.defineProperty(ASS_Event.prototype, 'Duration', { get: ASS_Event.prototype.get_Duration, set: ASS_Event.prototype.set_Duration }); ASS_Event.prototype.get_ReadOrder = ASS_Event.prototype.get_ReadOrder = function () { const self = this.ptr; return _emscripten_bind_ASS_Event_get_ReadOrder_0(self) }; ASS_Event.prototype.set_ReadOrder = ASS_Event.prototype.set_ReadOrder = function (arg0) { const self = this.ptr; if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; _emscripten_bind_ASS_Event_set_ReadOrder_1(self, arg0) }; Object.defineProperty(ASS_Event.prototype, 'ReadOrder', { get: ASS_Event.prototype.get_ReadOrder, set: ASS_Event.prototype.set_ReadOrder }); ASS_Event.prototype.get_Layer = ASS_Event.prototype.get_Layer = function () { const self = this.ptr; return _emscripten_bind_ASS_Event_get_Layer_0(self) }; ASS_Event.prototype.set_Layer = ASS_Event.prototype.set_Layer = function (arg0) { const self = this.ptr; if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; _emscripten_bind_ASS_Event_set_Layer_1(self, arg0) }; Object.defineProperty(ASS_Event.prototype, 'Layer', { get: ASS_Event.prototype.get_Layer, set: ASS_Event.prototype.set_Layer }); ASS_Event.prototype.get_Style = ASS_Event.prototype.get_Style = function () { const self = this.ptr; return _emscripten_bind_ASS_Event_get_Style_0(self) }; ASS_Event.prototype.set_Style = ASS_Event.prototype.set_Style = function (arg0) { const self = this.ptr; if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; _emscripten_bind_ASS_Event_set_Style_1(self, arg0) }; Object.defineProperty(ASS_Event.prototype, 'Style', { get: ASS_Event.prototype.get_Style, set: ASS_Event.prototype.set_Style }); ASS_Event.prototype.get_Name = ASS_Event.prototype.get_Name = function () { const self = this.ptr; return UTF8ToString(_emscripten_bind_ASS_Event_get_Name_0(self)) }; ASS_Event.prototype.set_Name = ASS_Event.prototype.set_Name = function (arg0) { const self = this.ptr; ensureCache.prepare(); if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; else arg0 = ensureString(arg0, true); _emscripten_bind_ASS_Event_set_Name_1(self, arg0) }; Object.defineProperty(ASS_Event.prototype, 'Name', { get: ASS_Event.prototype.get_Name, set: ASS_Event.prototype.set_Name }); ASS_Event.prototype.get_MarginL = ASS_Event.prototype.get_MarginL = function () { const self = this.ptr; return _emscripten_bind_ASS_Event_get_MarginL_0(self) }; ASS_Event.prototype.set_MarginL = ASS_Event.prototype.set_MarginL = function (arg0) { const self = this.ptr; if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; _emscripten_bind_ASS_Event_set_MarginL_1(self, arg0) }; Object.defineProperty(ASS_Event.prototype, 'MarginL', { get: ASS_Event.prototype.get_MarginL, set: ASS_Event.prototype.set_MarginL }); ASS_Event.prototype.get_MarginR = ASS_Event.prototype.get_MarginR = function () { const self = this.ptr; return _emscripten_bind_ASS_Event_get_MarginR_0(self) }; ASS_Event.prototype.set_MarginR = ASS_Event.prototype.set_MarginR = function (arg0) { const self = this.ptr; if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; _emscripten_bind_ASS_Event_set_MarginR_1(self, arg0) }; Object.defineProperty(ASS_Event.prototype, 'MarginR', { get: ASS_Event.prototype.get_MarginR, set: ASS_Event.prototype.set_MarginR }); ASS_Event.prototype.get_MarginV = ASS_Event.prototype.get_MarginV = function () { const self = this.ptr; return _emscripten_bind_ASS_Event_get_MarginV_0(self) }; ASS_Event.prototype.set_MarginV = ASS_Event.prototype.set_MarginV = function (arg0) { const self = this.ptr; if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; _emscripten_bind_ASS_Event_set_MarginV_1(self, arg0) }; Object.defineProperty(ASS_Event.prototype, 'MarginV', { get: ASS_Event.prototype.get_MarginV, set: ASS_Event.prototype.set_MarginV }); ASS_Event.prototype.get_Effect = ASS_Event.prototype.get_Effect = function () { const self = this.ptr; return UTF8ToString(_emscripten_bind_ASS_Event_get_Effect_0(self)) }; ASS_Event.prototype.set_Effect = ASS_Event.prototype.set_Effect = function (arg0) { const self = this.ptr; ensureCache.prepare(); if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; else arg0 = ensureString(arg0, true); _emscripten_bind_ASS_Event_set_Effect_1(self, arg0) }; Object.defineProperty(ASS_Event.prototype, 'Effect', { get: ASS_Event.prototype.get_Effect, set: ASS_Event.prototype.set_Effect }); ASS_Event.prototype.get_Text = ASS_Event.prototype.get_Text = function () { const self = this.ptr; return UTF8ToString(_emscripten_bind_ASS_Event_get_Text_0(self)) }; ASS_Event.prototype.set_Text = ASS_Event.prototype.set_Text = function (arg0) { const self = this.ptr; ensureCache.prepare(); if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; else arg0 = ensureString(arg0, true); _emscripten_bind_ASS_Event_set_Text_1(self, arg0) }; Object.defineProperty(ASS_Event.prototype, 'Text', { get: ASS_Event.prototype.get_Text, set: ASS_Event.prototype.set_Text }); function RenderResult () { throw 'cannot construct a RenderResult, no constructor in IDL' }RenderResult.prototype = Object.create(WrapperObject.prototype); RenderResult.prototype.constructor = RenderResult; RenderResult.prototype.__class__ = RenderResult; RenderResult.__cache__ = {}; Module.RenderResult = RenderResult; RenderResult.prototype.get_changed = RenderResult.prototype.get_changed = function () { const self = this.ptr; return _emscripten_bind_RenderResult_get_changed_0(self) }; RenderResult.prototype.set_changed = RenderResult.prototype.set_changed = function (arg0) { const self = this.ptr; if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; _emscripten_bind_RenderResult_set_changed_1(self, arg0) }; Object.defineProperty(RenderResult.prototype, 'changed', { get: RenderResult.prototype.get_changed, set: RenderResult.prototype.set_changed }); RenderResult.prototype.get_time = RenderResult.prototype.get_time = function () { const self = this.ptr; return _emscripten_bind_RenderResult_get_time_0(self) }; RenderResult.prototype.set_time = RenderResult.prototype.set_time = function (arg0) { const self = this.ptr; if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; _emscripten_bind_RenderResult_set_time_1(self, arg0) }; Object.defineProperty(RenderResult.prototype, 'time', { get: RenderResult.prototype.get_time, set: RenderResult.prototype.set_time }); RenderResult.prototype.get_x = RenderResult.prototype.get_x = function () { const self = this.ptr; return _emscripten_bind_RenderResult_get_x_0(self) }; RenderResult.prototype.set_x = RenderResult.prototype.set_x = function (arg0) { const self = this.ptr; if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; _emscripten_bind_RenderResult_set_x_1(self, arg0) }; Object.defineProperty(RenderResult.prototype, 'x', { get: RenderResult.prototype.get_x, set: RenderResult.prototype.set_x }); RenderResult.prototype.get_y = RenderResult.prototype.get_y = function () { const self = this.ptr; return _emscripten_bind_RenderResult_get_y_0(self) }; RenderResult.prototype.set_y = RenderResult.prototype.set_y = function (arg0) { const self = this.ptr; if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; _emscripten_bind_RenderResult_set_y_1(self, arg0) }; Object.defineProperty(RenderResult.prototype, 'y', { get: RenderResult.prototype.get_y, set: RenderResult.prototype.set_y }); RenderResult.prototype.get_w = RenderResult.prototype.get_w = function () { const self = this.ptr; return _emscripten_bind_RenderResult_get_w_0(self) }; RenderResult.prototype.set_w = RenderResult.prototype.set_w = function (arg0) { const self = this.ptr; if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; _emscripten_bind_RenderResult_set_w_1(self, arg0) }; Object.defineProperty(RenderResult.prototype, 'w', { get: RenderResult.prototype.get_w, set: RenderResult.prototype.set_w }); RenderResult.prototype.get_h = RenderResult.prototype.get_h = function () { const self = this.ptr; return _emscripten_bind_RenderResult_get_h_0(self) }; RenderResult.prototype.set_h = RenderResult.prototype.set_h = function (arg0) { const self = this.ptr; if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; _emscripten_bind_RenderResult_set_h_1(self, arg0) }; Object.defineProperty(RenderResult.prototype, 'h', { get: RenderResult.prototype.get_h, set: RenderResult.prototype.set_h }); RenderResult.prototype.get_image = RenderResult.prototype.get_image = function () { const self = this.ptr; return _emscripten_bind_RenderResult_get_image_0(self) }; RenderResult.prototype.set_image = RenderResult.prototype.set_image = function (arg0) { const self = this.ptr; ensureCache.prepare(); if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; else arg0 = ensureString(arg0, false); _emscripten_bind_RenderResult_set_image_1(self, arg0) }; Object.defineProperty(RenderResult.prototype, 'image', { get: RenderResult.prototype.get_image, set: RenderResult.prototype.set_image }); RenderResult.prototype.get_next = RenderResult.prototype.get_next = function () { const self = this.ptr; return wrapPointer(_emscripten_bind_RenderResult_get_next_0(self), RenderResult) }; RenderResult.prototype.set_next = RenderResult.prototype.set_next = function (arg0) { const self = this.ptr; if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; _emscripten_bind_RenderResult_set_next_1(self, arg0) }; Object.defineProperty(RenderResult.prototype, 'next', { get: RenderResult.prototype.get_next, set: RenderResult.prototype.set_next }); function ASS_Track () { throw 'cannot construct a ASS_Track, no constructor in IDL' }ASS_Track.prototype = Object.create(WrapperObject.prototype); ASS_Track.prototype.constructor = ASS_Track; ASS_Track.prototype.__class__ = ASS_Track; ASS_Track.__cache__ = {}; Module.ASS_Track = ASS_Track; ASS_Track.prototype.get_n_styles = ASS_Track.prototype.get_n_styles = function () { const self = this.ptr; return _emscripten_bind_ASS_Track_get_n_styles_0(self) }; ASS_Track.prototype.set_n_styles = ASS_Track.prototype.set_n_styles = function (arg0) { const self = this.ptr; if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; _emscripten_bind_ASS_Track_set_n_styles_1(self, arg0) }; Object.defineProperty(ASS_Track.prototype, 'n_styles', { get: ASS_Track.prototype.get_n_styles, set: ASS_Track.prototype.set_n_styles }); ASS_Track.prototype.get_max_styles = ASS_Track.prototype.get_max_styles = function () { const self = this.ptr; return _emscripten_bind_ASS_Track_get_max_styles_0(self) }; ASS_Track.prototype.set_max_styles = ASS_Track.prototype.set_max_styles = function (arg0) { const self = this.ptr; if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; _emscripten_bind_ASS_Track_set_max_styles_1(self, arg0) }; Object.defineProperty(ASS_Track.prototype, 'max_styles', { get: ASS_Track.prototype.get_max_styles, set: ASS_Track.prototype.set_max_styles }); ASS_Track.prototype.get_n_events = ASS_Track.prototype.get_n_events = function () { const self = this.ptr; return _emscripten_bind_ASS_Track_get_n_events_0(self) }; ASS_Track.prototype.set_n_events = ASS_Track.prototype.set_n_events = function (arg0) { const self = this.ptr; if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; _emscripten_bind_ASS_Track_set_n_events_1(self, arg0) }; Object.defineProperty(ASS_Track.prototype, 'n_events', { get: ASS_Track.prototype.get_n_events, set: ASS_Track.prototype.set_n_events }); ASS_Track.prototype.get_max_events = ASS_Track.prototype.get_max_events = function () { const self = this.ptr; return _emscripten_bind_ASS_Track_get_max_events_0(self) }; ASS_Track.prototype.set_max_events = ASS_Track.prototype.set_max_events = function (arg0) { const self = this.ptr; if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; _emscripten_bind_ASS_Track_set_max_events_1(self, arg0) }; Object.defineProperty(ASS_Track.prototype, 'max_events', { get: ASS_Track.prototype.get_max_events, set: ASS_Track.prototype.set_max_events }); ASS_Track.prototype.get_styles = ASS_Track.prototype.get_styles = function (arg0) { const self = this.ptr; if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; return wrapPointer(_emscripten_bind_ASS_Track_get_styles_1(self, arg0), ASS_Style) }; ASS_Track.prototype.set_styles = ASS_Track.prototype.set_styles = function (arg0, arg1) { const self = this.ptr; ensureCache.prepare(); if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; if (arg1 && typeof arg1 === 'object')arg1 = arg1.ptr; _emscripten_bind_ASS_Track_set_styles_2(self, arg0, arg1) }; Object.defineProperty(ASS_Track.prototype, 'styles', { get: ASS_Track.prototype.get_styles, set: ASS_Track.prototype.set_styles }); ASS_Track.prototype.get_events = ASS_Track.prototype.get_events = function (arg0) { const self = this.ptr; if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; return wrapPointer(_emscripten_bind_ASS_Track_get_events_1(self, arg0), ASS_Event) }; ASS_Track.prototype.set_events = ASS_Track.prototype.set_events = function (arg0, arg1) { const self = this.ptr; ensureCache.prepare(); if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; if (arg1 && typeof arg1 === 'object')arg1 = arg1.ptr; _emscripten_bind_ASS_Track_set_events_2(self, arg0, arg1) }; Object.defineProperty(ASS_Track.prototype, 'events', { get: ASS_Track.prototype.get_events, set: ASS_Track.prototype.set_events }); ASS_Track.prototype.get_style_format = ASS_Track.prototype.get_style_format = function () { const self = this.ptr; return UTF8ToString(_emscripten_bind_ASS_Track_get_style_format_0(self)) }; ASS_Track.prototype.set_style_format = ASS_Track.prototype.set_style_format = function (arg0) { const self = this.ptr; ensureCache.prepare(); if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; else arg0 = ensureString(arg0, true); _emscripten_bind_ASS_Track_set_style_format_1(self, arg0) }; Object.defineProperty(ASS_Track.prototype, 'style_format', { get: ASS_Track.prototype.get_style_format, set: ASS_Track.prototype.set_style_format }); ASS_Track.prototype.get_event_format = ASS_Track.prototype.get_event_format = function () { const self = this.ptr; return UTF8ToString(_emscripten_bind_ASS_Track_get_event_format_0(self)) }; ASS_Track.prototype.set_event_format = ASS_Track.prototype.set_event_format = function (arg0) { const self = this.ptr; ensureCache.prepare(); if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; else arg0 = ensureString(arg0, true); _emscripten_bind_ASS_Track_set_event_format_1(self, arg0) }; Object.defineProperty(ASS_Track.prototype, 'event_format', { get: ASS_Track.prototype.get_event_format, set: ASS_Track.prototype.set_event_format }); ASS_Track.prototype.get_PlayResX = ASS_Track.prototype.get_PlayResX = function () { const self = this.ptr; return _emscripten_bind_ASS_Track_get_PlayResX_0(self) }; ASS_Track.prototype.set_PlayResX = ASS_Track.prototype.set_PlayResX = function (arg0) { const self = this.ptr; if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; _emscripten_bind_ASS_Track_set_PlayResX_1(self, arg0) }; Object.defineProperty(ASS_Track.prototype, 'PlayResX', { get: ASS_Track.prototype.get_PlayResX, set: ASS_Track.prototype.set_PlayResX }); ASS_Track.prototype.get_PlayResY = ASS_Track.prototype.get_PlayResY = function () { const self = this.ptr; return _emscripten_bind_ASS_Track_get_PlayResY_0(self) }; ASS_Track.prototype.set_PlayResY = ASS_Track.prototype.set_PlayResY = function (arg0) { const self = this.ptr; if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; _emscripten_bind_ASS_Track_set_PlayResY_1(self, arg0) }; Object.defineProperty(ASS_Track.prototype, 'PlayResY', { get: ASS_Track.prototype.get_PlayResY, set: ASS_Track.prototype.set_PlayResY }); ASS_Track.prototype.get_Timer = ASS_Track.prototype.get_Timer = function () { const self = this.ptr; return _emscripten_bind_ASS_Track_get_Timer_0(self) }; ASS_Track.prototype.set_Timer = ASS_Track.prototype.set_Timer = function (arg0) { const self = this.ptr; if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; _emscripten_bind_ASS_Track_set_Timer_1(self, arg0) }; Object.defineProperty(ASS_Track.prototype, 'Timer', { get: ASS_Track.prototype.get_Timer, set: ASS_Track.prototype.set_Timer }); ASS_Track.prototype.get_WrapStyle = ASS_Track.prototype.get_WrapStyle = function () { const self = this.ptr; return _emscripten_bind_ASS_Track_get_WrapStyle_0(self) }; ASS_Track.prototype.set_WrapStyle = ASS_Track.prototype.set_WrapStyle = function (arg0) { const self = this.ptr; if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; _emscripten_bind_ASS_Track_set_WrapStyle_1(self, arg0) }; Object.defineProperty(ASS_Track.prototype, 'WrapStyle', { get: ASS_Track.prototype.get_WrapStyle, set: ASS_Track.prototype.set_WrapStyle }); ASS_Track.prototype.get_ScaledBorderAndShadow = ASS_Track.prototype.get_ScaledBorderAndShadow = function () { const self = this.ptr; return _emscripten_bind_ASS_Track_get_ScaledBorderAndShadow_0(self) }; ASS_Track.prototype.set_ScaledBorderAndShadow = ASS_Track.prototype.set_ScaledBorderAndShadow = function (arg0) { const self = this.ptr; if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; _emscripten_bind_ASS_Track_set_ScaledBorderAndShadow_1(self, arg0) }; Object.defineProperty(ASS_Track.prototype, 'ScaledBorderAndShadow', { get: ASS_Track.prototype.get_ScaledBorderAndShadow, set: ASS_Track.prototype.set_ScaledBorderAndShadow }); ASS_Track.prototype.get_Kerning = ASS_Track.prototype.get_Kerning = function () { const self = this.ptr; return _emscripten_bind_ASS_Track_get_Kerning_0(self) }; ASS_Track.prototype.set_Kerning = ASS_Track.prototype.set_Kerning = function (arg0) { const self = this.ptr; if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; _emscripten_bind_ASS_Track_set_Kerning_1(self, arg0) }; Object.defineProperty(ASS_Track.prototype, 'Kerning', { get: ASS_Track.prototype.get_Kerning, set: ASS_Track.prototype.set_Kerning }); ASS_Track.prototype.get_Language = ASS_Track.prototype.get_Language = function () { const self = this.ptr; return UTF8ToString(_emscripten_bind_ASS_Track_get_Language_0(self)) }; ASS_Track.prototype.set_Language = ASS_Track.prototype.set_Language = function (arg0) { const self = this.ptr; ensureCache.prepare(); if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; else arg0 = ensureString(arg0, true); _emscripten_bind_ASS_Track_set_Language_1(self, arg0) }; Object.defineProperty(ASS_Track.prototype, 'Language', { get: ASS_Track.prototype.get_Language, set: ASS_Track.prototype.set_Language }); ASS_Track.prototype.get_default_style = ASS_Track.prototype.get_default_style = function () { const self = this.ptr; return _emscripten_bind_ASS_Track_get_default_style_0(self) }; ASS_Track.prototype.set_default_style = ASS_Track.prototype.set_default_style = function (arg0) { const self = this.ptr; if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; _emscripten_bind_ASS_Track_set_default_style_1(self, arg0) }; Object.defineProperty(ASS_Track.prototype, 'default_style', { get: ASS_Track.prototype.get_default_style, set: ASS_Track.prototype.set_default_style }); ASS_Track.prototype.get_name = ASS_Track.prototype.get_name = function () { const self = this.ptr; return UTF8ToString(_emscripten_bind_ASS_Track_get_name_0(self)) }; ASS_Track.prototype.set_name = ASS_Track.prototype.set_name = function (arg0) { const self = this.ptr; ensureCache.prepare(); if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; else arg0 = ensureString(arg0, true); _emscripten_bind_ASS_Track_set_name_1(self, arg0) }; Object.defineProperty(ASS_Track.prototype, 'name', { get: ASS_Track.prototype.get_name, set: ASS_Track.prototype.set_name }); function JASSUB () { this.ptr = _emscripten_bind_JASSUB_JASSUB_0(); getCache(JASSUB)[this.ptr] = this }JASSUB.prototype = Object.create(WrapperObject.prototype); JASSUB.prototype.constructor = JASSUB; JASSUB.prototype.__class__ = JASSUB; JASSUB.__cache__ = {}; Module.JASSUB = JASSUB; JASSUB.prototype.setLogLevel = JASSUB.prototype.setLogLevel = function (level) { const self = this.ptr; if (level && typeof level === 'object')level = level.ptr; _emscripten_bind_JASSUB_setLogLevel_1(self, level) }; JASSUB.prototype.setDropAnimations = JASSUB.prototype.setDropAnimations = function (value) { const self = this.ptr; if (value && typeof value === 'object')value = value.ptr; _emscripten_bind_JASSUB_setDropAnimations_1(self, value) }; JASSUB.prototype.initLibrary = JASSUB.prototype.initLibrary = function (frame_w, frame_h, default_font) { const self = this.ptr; ensureCache.prepare(); if (frame_w && typeof frame_w === 'object')frame_w = frame_w.ptr; if (frame_h && typeof frame_h === 'object')frame_h = frame_h.ptr; if (default_font && typeof default_font === 'object')default_font = default_font.ptr; else default_font = ensureString(default_font, false); _emscripten_bind_JASSUB_initLibrary_3(self, frame_w, frame_h, default_font) }; JASSUB.prototype.createTrackMem = JASSUB.prototype.createTrackMem = function (buf, bufsize) { const self = this.ptr; ensureCache.prepare(); if (buf && typeof buf === 'object')buf = buf.ptr; else buf = ensureString(buf, false); if (bufsize && typeof bufsize === 'object')bufsize = bufsize.ptr; _emscripten_bind_JASSUB_createTrackMem_2(self, buf, bufsize) }; JASSUB.prototype.removeTrack = JASSUB.prototype.removeTrack = function () { const self = this.ptr; _emscripten_bind_JASSUB_removeTrack_0(self) }; JASSUB.prototype.resizeCanvas = JASSUB.prototype.resizeCanvas = function (frame_w, frame_h) { const self = this.ptr; if (frame_w && typeof frame_w === 'object')frame_w = frame_w.ptr; if (frame_h && typeof frame_h === 'object')frame_h = frame_h.ptr; _emscripten_bind_JASSUB_resizeCanvas_2(self, frame_w, frame_h) }; JASSUB.prototype.renderImage = JASSUB.prototype.renderImage = function (time, force) { const self = this.ptr; if (time && typeof time === 'object')time = time.ptr; if (force && typeof force === 'object')force = force.ptr; return wrapPointer(_emscripten_bind_JASSUB_renderImage_2(self, time, force), RenderResult) }; JASSUB.prototype.quitLibrary = JASSUB.prototype.quitLibrary = function () { const self = this.ptr; _emscripten_bind_JASSUB_quitLibrary_0(self) }; JASSUB.prototype.reloadLibrary = JASSUB.prototype.reloadLibrary = function () { const self = this.ptr; _emscripten_bind_JASSUB_reloadLibrary_0(self) }; JASSUB.prototype.addFont = JASSUB.prototype.addFont = function (name, data, data_size) { const self = this.ptr; ensureCache.prepare(); if (name && typeof name === 'object')name = name.ptr; else name = ensureString(name, false); if (data && typeof data === 'object')data = data.ptr; else data = ensureString(data, false); if (data_size && typeof data_size === 'object')data_size = data_size.ptr; _emscripten_bind_JASSUB_addFont_3(self, name, data, data_size) }; JASSUB.prototype.reloadFonts = JASSUB.prototype.reloadFonts = function () { const self = this.ptr; _emscripten_bind_JASSUB_reloadFonts_0(self) }; JASSUB.prototype.setMargin = JASSUB.prototype.setMargin = function (top, bottom, left, right) { const self = this.ptr; if (top && typeof top === 'object')top = top.ptr; if (bottom && typeof bottom === 'object')bottom = bottom.ptr; if (left && typeof left === 'object')left = left.ptr; if (right && typeof right === 'object')right = right.ptr; _emscripten_bind_JASSUB_setMargin_4(self, top, bottom, left, right) }; JASSUB.prototype.getEventCount = JASSUB.prototype.getEventCount = function () { const self = this.ptr; return _emscripten_bind_JASSUB_getEventCount_0(self) }; JASSUB.prototype.allocEvent = JASSUB.prototype.allocEvent = function () { const self = this.ptr; return _emscripten_bind_JASSUB_allocEvent_0(self) }; JASSUB.prototype.allocStyle = JASSUB.prototype.allocStyle = function () { const self = this.ptr; return _emscripten_bind_JASSUB_allocStyle_0(self) }; JASSUB.prototype.removeEvent = JASSUB.prototype.removeEvent = function (eid) { const self = this.ptr; if (eid && typeof eid === 'object')eid = eid.ptr; _emscripten_bind_JASSUB_removeEvent_1(self, eid) }; JASSUB.prototype.getStyleCount = JASSUB.prototype.getStyleCount = function () { const self = this.ptr; return _emscripten_bind_JASSUB_getStyleCount_0(self) }; JASSUB.prototype.getStyleByName = JASSUB.prototype.getStyleByName = function (name) { const self = this.ptr; ensureCache.prepare(); if (name && typeof name === 'object')name = name.ptr; else name = ensureString(name, false); return _emscripten_bind_JASSUB_getStyleByName_1(self, name) }; JASSUB.prototype.removeStyle = JASSUB.prototype.removeStyle = function (eid) { const self = this.ptr; if (eid && typeof eid === 'object')eid = eid.ptr; _emscripten_bind_JASSUB_removeStyle_1(self, eid) }; JASSUB.prototype.removeAllEvents = JASSUB.prototype.removeAllEvents = function () { const self = this.ptr; _emscripten_bind_JASSUB_removeAllEvents_0(self) }; JASSUB.prototype.setMemoryLimits = JASSUB.prototype.setMemoryLimits = function (glyph_limit, bitmap_cache_limit) { const self = this.ptr; if (glyph_limit && typeof glyph_limit === 'object')glyph_limit = glyph_limit.ptr; if (bitmap_cache_limit && typeof bitmap_cache_limit === 'object')bitmap_cache_limit = bitmap_cache_limit.ptr; _emscripten_bind_JASSUB_setMemoryLimits_2(self, glyph_limit, bitmap_cache_limit) }; JASSUB.prototype.renderBlend = JASSUB.prototype.renderBlend = function (tm, force) { const self = this.ptr; if (tm && typeof tm === 'object')tm = tm.ptr; if (force && typeof force === 'object')force = force.ptr; return wrapPointer(_emscripten_bind_JASSUB_renderBlend_2(self, tm, force), RenderResult) }; JASSUB.prototype.get_track = JASSUB.prototype.get_track = function () { const self = this.ptr; return wrapPointer(_emscripten_bind_JASSUB_get_track_0(self), ASS_Track) }; JASSUB.prototype.set_track = JASSUB.prototype.set_track = function (arg0) { const self = this.ptr; if (arg0 && typeof arg0 === 'object')arg0 = arg0.ptr; _emscripten_bind_JASSUB_set_track_1(self, arg0) }; Object.defineProperty(JASSUB.prototype, 'track', { get: JASSUB.prototype.get_track, set: JASSUB.prototype.set_track }); JASSUB.prototype.__destroy__ = JASSUB.prototype.__destroy__ = function () { const self = this.ptr; _emscripten_bind_JASSUB___destroy___0(self) }; const hasNativeConsole = typeof console !== 'undefined'; function makeCustomConsole () { const console = (function () { function postConsoleMessage (command, args) { postMessage({ target: 'console', command, content: JSON.stringify(Array.prototype.slice.call(args)) }) } return { log: function () { postConsoleMessage('log', arguments) }, debug: function () { postConsoleMessage('debug', arguments) }, info: function () { postConsoleMessage('info', arguments) }, warn: function () { postConsoleMessage('warn', arguments) }, error: function () { postConsoleMessage('error', arguments) } } }()); return console }
/* eslint-disable no-global-assign */
/* global Module, FS, readBinary, readAsync, read_, calledMain, addRunDependency, removeRunDependency, buffer, assert, updateGlobalBufferAndViews */
Module = Module || {}

Module.preRun = Module.preRun || []

Module.preRun.push(function () {
  Module.FS.createPath('/', 'fonts', true, true)
  Module.FS.createPath('/', 'fontconfig', true, true)

  if (!self.subContent) {
    self.subContent = read_(self.subUrl)
  }

  self.writeAvailableFontsToFS(self.subContent)

  if (self.fallbackFont) {
    const fallbackFontData = ArrayBuffer.isView(self.fallbackFont) ? self.fallbackFont : readBinary(self.fallbackFont)
    Module.FS.writeFile('/fonts/.fallback', fallbackFontData, { encoding: 'binary' })
  }
})

const textByteLength = (input) => new TextEncoder().encode(input).buffer.byteLength

Module.onRuntimeInitialized = function () {
  self.jassubObj = new Module.JASSUB()

  self.jassubObj.initLibrary(self.width, self.height, '/fonts/.fallback')

  for (const font of self.fontFiles || []) {
    self.asyncWrite(font)
  }

  self.jassubObj.createTrackMem(self.subContent, textByteLength(self.subContent))
  self.jassubObj.setDropAnimations(self.dropAllAnimations)

  if (self.libassMemoryLimit > 0 || self.libassGlyphLimit > 0) {
    self.jassubObj.setMemoryLimits(self.libassGlyphLimit, self.libassMemoryLimit)
  }
}

Module.print = function (text) {
  if (arguments.length > 1) text = Array.prototype.slice.call(arguments).join(' ')
  console.log(text)
}
Module.printErr = function (text) {
  if (arguments.length > 1) text = Array.prototype.slice.call(arguments).join(' ')
  console.error(text)
}

Module.FS = FS

self.delay = 0 // approximate delay (time of render + postMessage + drawImage), for example 1/60 or 0
self.lastCurrentTime = 0
self.rate = 1
self.rafId = null
self.nextIsRaf = false
self.lastCurrentTimeReceivedAt = Date.now()
self.targetFps = 24
self.libassMemoryLimit = 0 // in MiB
self.dropAllAnimations = false

self.width = 0
self.height = 0

self.fontMap_ = {}
self.fontId = 0

let asyncRender = false

self.addFont = function (data) {
  self.asyncWrite(data.font)
}

/**
 * Make the font accessible by libass by writing it to the virtual FS.
 * @param {!string} font the font name.
 */
self.writeFontToFS = function (value) {
  value = value.trim()

  if (value.startsWith('@')) {
    value = value.substring(1)
  }

  const font = value.toLowerCase()

  if (self.fontMap_[font]) return

  self.fontMap_[font] = true

  if (!self.availableFonts[font]) {
    if (self.useLocalFonts) {
      postMessage({ target: 'getLocalFont', font: value })
    }
    return
  }

  self.asyncWrite(self.availableFonts[font])
}

self.asyncWrite = function (font) {
  if (ArrayBuffer.isView(font)) {
    Module.FS.writeFile('/fonts/font-' + (self.fontId++), font, { encoding: 'binary' })
    self.jassubObj.reloadFonts()
  } else {
    readAsync(font, fontData => {
      Module.FS.writeFile('/fonts/font-' + (self.fontId++), new Uint8Array(fontData), { encoding: 'binary' })
      self.jassubObj.reloadFonts()
    })
  }
}

/**
 * Write all font's mentioned in the .ass file to the virtual FS.
 * @param {!string} content the file content.
 */
self.writeAvailableFontsToFS = function (content) {
  if (!self.availableFonts) return

  const sections = parseAss(content)

  for (let i = 0; i < sections.length; i++) {
    for (let j = 0; j < sections[i].body.length; j++) {
      if (sections[i].body[j].key === 'Style') {
        self.writeFontToFS(sections[i].body[j].value.Fontname)
      }
    }
  }

  const regex = /\\fn([^\\}]*?)[\\}]/g
  let matches
  while ((matches = regex.exec(self.subContent)) !== null) {
    self.writeFontToFS(matches[1])
  }
}
/**
 * Set the subtitle track.
 * @param {!string} content the content of the subtitle file.
 */
self.setTrack = function (data) {
  // Make sure that the fonts are loaded
  self.writeAvailableFontsToFS(data.content)

  // Tell libass to render the new track
  self.jassubObj.createTrackMem(self.subContent, textByteLength(self.subContent))
  self.renderLoop()
}

/**
 * Remove subtitle track.
 */
self.freeTrack = function () {
  self.jassubObj.removeTrack()
  self.renderLoop()
}

/**
 * Set the subtitle track.
 * @param {!string} url the URL of the subtitle file.
 */
self.setTrackByUrl = function (data) {
  const content = read_(data.url)

  self.setTrack({ content })
}

self.resize = (width, height) => {
  self.width = width
  self.height = height
  if (self.offscreenCanvas) {
    self.offscreenCanvas.width = width
    self.offscreenCanvas.height = height
  }
  self.jassubObj.resizeCanvas(width, height)
}

self.getCurrentTime = function () {
  const diff = (Date.now() - self.lastCurrentTimeReceivedAt) / 1000
  if (self._isPaused) {
    return self.lastCurrentTime
  } else {
    if (diff > 5) {
      console.error('Didn\'t received currentTime > 5 seconds. Assuming video was paused.')
      self.setIsPaused(true)
    }
    return self.lastCurrentTime + (diff * self.rate)
  }
}
self.setCurrentTime = function (currentTime) {
  self.lastCurrentTime = currentTime
  self.lastCurrentTimeReceivedAt = Date.now()
  if (!self.rafId) {
    if (self.nextIsRaf) {
      self.rafId = self.requestAnimationFrame(self.renderLoop)
    } else {
      self.renderLoop()

      // Give onmessage chance to receive all queued messages
      setTimeout(function () {
        self.nextIsRaf = false
      }, 20)
    }
  }
}

self._isPaused = true
self.setIsPaused = function (isPaused) {
  if (isPaused !== self._isPaused) {
    self._isPaused = isPaused
    if (isPaused) {
      if (self.rafId) {
        clearTimeout(self.rafId)
        self.rafId = null
      }
    } else {
      self.lastCurrentTimeReceivedAt = Date.now()
      self.rafId = self.requestAnimationFrame(self.renderLoop)
    }
  }
}

self.renderImageData = (time, force) => {
  const renderStartTime = Date.now()
  let result = null
  if (self.blendMode === 'wasm') {
    result = self.jassubObj.renderBlend(time, force)
    result.times = {
      renderTime: Date.now() - renderStartTime - result.time | 0,
      blendTime: result.time | 0
    }
  } else {
    result = self.jassubObj.renderImage(time, force)
    result.times = {
      renderTime: Date.now() - renderStartTime - result.time | 0,
      cppDecodeTime: result.time | 0
    }
  }
  return result
}

self.processRender = (result) => {
  const images = []
  let buffers = []
  const decodeStartTime = Date.now()
  // use callback to not rely on async/await
  if (asyncRender) {
    const promises = []
    for (let image = result; image.ptr !== 0; image = image.next) {
      if (image.image) {
        images.push({ w: image.w, h: image.h, x: image.x, y: image.y })
        promises.push(createImageBitmap(new ImageData(HEAPU8C.subarray(image.image, image.image + image.w * image.h * 4), image.w, image.h)))
      }
    }
    Promise.all(promises).then(bitmaps => {
      for (let i = 0; i < images.length; i++) {
        images[i].image = bitmaps[i]
      }
      buffers = bitmaps
      self.paintImages({ images, buffers, times: result.times, decodeStartTime })
    })
  } else {
    for (let image = result; image.ptr !== 0; image = image.next) {
      if (image.image) {
        images.push({ w: image.w, h: image.h, x: image.x, y: image.y })
        buffers.push(buffer.slice(image.image, image.image + image.w * image.h * 4))
      }
    }
    self.paintImages({ images, buffers, times: result.times, decodeStartTime })
  }
}

self.render = (time, force) => {
  const result = self.renderImageData(time, force)
  if (result.changed !== 0 || force) {
    self.processRender(result)
  } else {
    postMessage({
      target: 'unbusy'
    })
  }
}

self.demand = data => {
  self.lastCurrentTime = data.time
  self.render(data.time)
}

self.renderLoop = (force) => {
  self.rafId = 0
  self.renderPending = false
  self.render(self.getCurrentTime() + self.delay, force)
  if (!self._isPaused) {
    self.rafId = self.requestAnimationFrame(self.renderLoop)
  }
}

self.paintImages = (data) => {
  data.times.decodeTime = Date.now() - data.decodeStartTime
  if (self.offscreenCanvasCtx) {
    const drawStartTime = Date.now()
    self.offscreenCanvasCtx.clearRect(0, 0, self.offscreenCanvas.width, self.offscreenCanvas.height)
    for (const image of data.images) {
      if (image.image) {
        if (asyncRender) {
          self.offscreenCanvasCtx.drawImage(image.image, image.x, image.y)
          image.image.close()
        } else {
          self.bufferCanvas.width = image.w
          self.bufferCanvas.height = image.h
          self.bufferCtx.putImageData(new ImageData(HEAPU8C.subarray(image.image, image.image + image.w * image.h * 4), image.w, image.h), 0, 0)
          self.offscreenCanvasCtx.drawImage(self.bufferCanvas, image.x, image.y)
        }
      }
    }
    if (self.debug) {
      data.times.drawTime = Date.now() - drawStartTime
      let total = 0
      for (const key in data.times) total += data.times[key]
      console.log('Bitmaps: ' + data.images.length + ' Total: ' + Math.round(total) + 'ms', data.times)
    }
  } else {
    postMessage({
      target: 'render',
      async: asyncRender,
      images: data.images,
      times: data.times
    }, data.buffers)
  }
  postMessage({
    target: 'unbusy'
  })
}

/**
 * Parse the content of an .ass file.
 * @param {!string} content the content of the file
 */
function parseAss (content) {
  let m, format, lastPart, parts, key, value, tmp, i, j, body
  const sections = []
  const lines = content.split(/[\r\n]+/g)
  for (i = 0; i < lines.length; i++) {
    m = lines[i].match(/^\[(.*)\]$/)
    if (m) {
      format = null
      sections.push({
        name: m[1],
        body: []
      })
    } else {
      if (/^\s*$/.test(lines[i])) continue
      if (sections.length === 0) continue
      body = sections[sections.length - 1].body
      if (lines[i][0] === ';') {
        body.push({
          type: 'comment',
          value: lines[i].substring(1)
        })
      } else {
        parts = lines[i].split(':')
        key = parts[0]
        value = parts.slice(1).join(':').trim()
        if (format || key === 'Format') {
          value = value.split(',')
          if (format && value.length > format.length) {
            lastPart = value.slice(format.length - 1).join(',')
            value = value.slice(0, format.length - 1)
            value.push(lastPart)
          }
          value = value.map(function (s) {
            return s.trim()
          })
          if (format) {
            tmp = {}
            for (j = 0; j < value.length; j++) {
              tmp[format[j]] = value[j]
            }
            value = tmp
          }
        }
        if (key === 'Format') {
          format = value
        }
        body.push({
          key,
          value
        })
      }
    }
  }

  return sections
};

self.requestAnimationFrame = (function () {
  // similar to Browser.requestAnimationFrame
  let nextRAF = 0
  return function (func) {
    // try to keep target fps (30fps) between calls to here
    const now = Date.now()
    if (nextRAF === 0) {
      nextRAF = now + 1000 / self.targetFps
    } else {
      while (now + 2 >= nextRAF) { // fudge a little, to avoid timer jitter causing us to do lots of delay:0
        nextRAF += 1000 / self.targetFps
      }
    }
    const delay = Math.max(nextRAF - now, 0)
    return setTimeout(func, delay)
    // return setTimeout(func, 1);
  }
})()


// Frame throttling

// Wait to start running until we receive some info from the client
addRunDependency('worker-init')

// buffer messages until the program starts to run

let messageBuffer = null
let messageResenderTimeout = null

function messageResender () {
  if (calledMain) {
    assert(messageBuffer && messageBuffer.length > 0)
    messageResenderTimeout = null
    messageBuffer.forEach(function (message) {
      onmessage(message)
    })
    messageBuffer = null
  } else {
    messageResenderTimeout = setTimeout(messageResender, 50)
  }
}

function _applyKeys (input, output) {
  const vargs = Object.keys(input)

  for (let i = 0; i < vargs.length; i++) {
    output[vargs[i]] = input[vargs[i]]
  }
}

self.init = data => {
  self.width = data.width
  self.height = data.height
  self.subUrl = data.subUrl
  self.subContent = data.subContent
  self.fontFiles = data.fonts
  self.fallbackFont = data.fallbackFont
  self.blendMode = data.blendMode
  asyncRender = data.asyncRender
  self.dropAllAnimations = !!data.dropAllAnimations || self.dropAllAnimations
  // Force fallback if engine does not support 'lossy' mode.
  // We only use createImageBitmap in the worker and historic WebKit versions supported
  // the API in the normal but not the worker scope, so we can't check this earlier.
  if (asyncRender && typeof createImageBitmap === 'undefined') {
    asyncRender = false
    console.error("'createImageBitmap' needed for 'asyncRender' unsupported!")
  }

  self.availableFonts = data.availableFonts
  self.debug = data.debug
  self.targetFps = data.targetFps || self.targetFps
  self.libassMemoryLimit = data.libassMemoryLimit || self.libassMemoryLimit
  self.libassGlyphLimit = data.libassGlyphLimit || 0
  self.useLocalFonts = data.useLocalFonts
  removeRunDependency('worker-init')
  postMessage({
    target: 'ready'
  })
}

self.canvas = data => {
  if (data.width == null) throw new Error('Invalid canvas size specified')
  self.resize(data.width, data.height)
  self.renderLoop()
}

self.video = data => {
  if (data.currentTime != null) self.setCurrentTime(data.currentTime)
  if (data.isPaused != null) self.setIsPaused(data.isPaused)
  self.rate = data.rate || self.rate
}

self.offscreenCanvas = data => {
  self.offscreenCanvas = data.transferable[0]
  self.offscreenCanvasCtx = self.offscreenCanvas.getContext('2d')
  self.bufferCanvas = new OffscreenCanvas(self.height, self.width)
  self.bufferCtx = self.bufferCanvas.getContext('2d')
}

self.destroy = () => {
  self.jassubObj.quitLibrary()
}

self.createEvent = data => {
  _applyKeys(data.event, self.jassubObj.track.get_events(self.jassubObj.allocEvent()))
}

self.getEvents = () => {
  const events = []
  for (let i = 0; i < self.jassubObj.getEventCount(); i++) {
    const evntPtr = self.jassubObj.track.get_events(i)
    events.push({
      Start: evntPtr.get_Start(),
      Duration: evntPtr.get_Duration(),
      ReadOrder: evntPtr.get_ReadOrder(),
      Layer: evntPtr.get_Layer(),
      Style: evntPtr.get_Style(),
      Name: evntPtr.get_Name(),
      MarginL: evntPtr.get_MarginL(),
      MarginR: evntPtr.get_MarginR(),
      MarginV: evntPtr.get_MarginV(),
      Effect: evntPtr.get_Effect(),
      Text: evntPtr.get_Text()
    })
  }
  postMessage({
    target: 'getEvents',
    events
  })
}

self.setEvent = data => {
  _applyKeys(data.event, self.jassubObj.track.get_events(data.index))
}

self.removeEvent = data => {
  self.jassubObj.removeEvent(data.index)
}

self.createStyle = data => {
  _applyKeys(data.style, self.jassubObj.track.get_styles(self.jassubObj.allocStyle()))
}

self.getStyles = () => {
  const styles = []
  for (let i = 0; i < self.jassubObj.getStyleCount(); i++) {
    const stylPtr = self.jassubObj.track.get_styles(i)
    styles.push({
      Name: stylPtr.get_Name(),
      FontName: stylPtr.get_FontName(),
      FontSize: stylPtr.get_FontSize(),
      PrimaryColour: stylPtr.get_PrimaryColour(),
      SecondaryColour: stylPtr.get_SecondaryColour(),
      OutlineColour: stylPtr.get_OutlineColour(),
      BackColour: stylPtr.get_BackColour(),
      Bold: stylPtr.get_Bold(),
      Italic: stylPtr.get_Italic(),
      Underline: stylPtr.get_Underline(),
      StrikeOut: stylPtr.get_StrikeOut(),
      ScaleX: stylPtr.get_ScaleX(),
      ScaleY: stylPtr.get_ScaleY(),
      Spacing: stylPtr.get_Spacing(),
      Angle: stylPtr.get_Angle(),
      BorderStyle: stylPtr.get_BorderStyle(),
      Outline: stylPtr.get_Outline(),
      Shadow: stylPtr.get_Shadow(),
      Alignment: stylPtr.get_Alignment(),
      MarginL: stylPtr.get_MarginL(),
      MarginR: stylPtr.get_MarginR(),
      MarginV: stylPtr.get_MarginV(),
      Encoding: stylPtr.get_Encoding(),
      treat_fontname_as_pattern: stylPtr.get_treat_fontname_as_pattern(),
      Blur: stylPtr.get_Blur(),
      Justify: stylPtr.get_Justify()
    })
  }
  postMessage({
    target: 'getStyles',
    time: Date.now(),
    styles
  })
}

self.setStyle = data => {
  _applyKeys(data.style, self.jassubObj.track.get_styles(data.index))
}

self.removeStyle = data => {
  self.jassubObj.removeStyle(data.index)
}

onmessage = message => {
  if (!calledMain && !message.data.preMain) {
    if (!messageBuffer) {
      messageBuffer = []
      messageResenderTimeout = setTimeout(messageResender, 50)
    }
    messageBuffer.push(message)
    return
  }
  if (calledMain && messageResenderTimeout) {
    clearTimeout(messageResenderTimeout)
    messageResender()
  }
  const data = message.data
  if (self[data.target]) {
    self[data.target](data)
  } else {
    throw new Error('Unknown event target ' + message.data.target)
  }
}

let HEAPU8C = null

// patch EMS function to include Uint8Clamped, but call old function too
updateGlobalBufferAndViews = (function (_super) {
  return function (buf) {
    _super(buf)
    HEAPU8C = new Uint8ClampedArray(buf)
  }
})(updateGlobalBufferAndViews)
